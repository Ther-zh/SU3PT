<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI PPT生成系统</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <!-- PPTXGenJS库将在需要时动态加载，使用更可靠的CDN源 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- 可编辑PPTX导出模块 -->
    <script src="pptx-exporter.js"></script>
    <style>
      :root {
        --primary-color: #3498db;
        --secondary-color: #2c3e50;
        --accent-color: #e74c3c;
        --background-color: #ffffff;
        --text-color: #2c3e50;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }

      body {
        background-color: #f5f5f5;
        overflow: hidden;
      }

      #app {
        display: flex;
        height: 100vh;
      }

      /* 侧边栏样式 */
      #sidebar {
        width: 250px;
        background-color: #2c3e50;
        color: white;
        padding: 20px;
        display: flex;
        flex-direction: column;
        box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
        transition: transform 0.3s;
        z-index: 100;
      }

      .logo {
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 20px;
        text-align: center;
        color: #3498db;
      }

      .mode-toggle {
        display: flex;
        margin-bottom: 20px;
        background-color: #34495e;
        border-radius: 5px;
        overflow: hidden;
      }

      .mode-btn {
        flex: 1;
        padding: 10px;
        text-align: center;
        cursor: pointer;
        transition: background-color 0.3s;
      }

      .mode-btn.active {
        background-color: #3498db;
      }

      .slide-list {
        flex: 1;
        overflow-y: auto;
        margin-bottom: 20px;
      }

      .slide-item {
        padding: 10px;
        margin-bottom: 8px;
        background-color: #34495e;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
        position: relative;
      }

      .slide-item.active {
        background-color: #3498db;
      }

      .slide-item:hover .slide-actions {
        display: flex;
      }

      .slide-actions {
        position: absolute;
        right: 5px;
        top: 5px;
        display: none;
        gap: 5px;
      }

      .slide-action {
        width: 20px;
        height: 20px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 3px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 12px;
      }

      .action-buttons {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      button {
        padding: 12px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        transition: background-color 0.3s;
      }

      .primary-btn {
        background-color: #3498db;
        color: white;
      }

      .secondary-btn {
        background-color: #e74c3c;
        color: white;
      }

      .save-btn {
        background-color: #2ecc71;
        color: white;
      }

      .export-btn {
        background-color: #9b59b6;
        color: white;
      }

      /* 主内容区样式 */
      #main-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        position: relative;
        overflow: hidden;
      }

      #presentation-area {
        flex: 1;
        position: relative;
        overflow: hidden;
        background-color: #f0f0f0; /* 改为灰色背景以突出幻灯片 */
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }

      /* 修改幻灯片样式 */
      .slide {
        position: absolute;
        /* 设置标准16:9的PPT比例 */
        width: 1024px;
        height: 576px;
        /* 防止在小屏幕上溢出 */
        max-width: 90vw;
        max-height: 90vh;
        display: flex;
        flex-direction: column;
        padding: 40px;
        transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        background-color: var(--background-color);
        color: var(--text-color);
        overflow: hidden;
        /* 添加边框和阴影增强边界感 */
        border: 1px solid #ddd;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        /* 居中显示 */
        margin: auto;
        /* 默认隐藏 */
        opacity: 0;
        visibility: hidden;
        transform: scale(0.95);
      }

      .slide.active {
        opacity: 1;
        visibility: visible;
        transform: scale(1);
        z-index: 10;
      }

      .slide.hidden {
        opacity: 0;
        visibility: hidden;
        transform: scale(0.95);
        z-index: 1;
      }

      /* 移除不需要的prev类样式 */
      .slide.prev {
        opacity: 0;
        visibility: hidden;
        transform: scale(0.95);
      }

      .slide-header {
        text-align: center;
        margin-bottom: 30px;
      }

      .slide-title {
        font-size: 36px;
        margin-bottom: 15px;
        color: var(--secondary-color);
      }

      .slide-subtitle {
        font-size: 20px;
        color: #7f8c8d;
      }

      .slide-body {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 20px;
        position: relative;
      }

      .slide-footer {
        text-align: center;
        color: #95a5a6;
        font-size: 14px;
      }

      /* 导航按钮 */
      .nav-buttons {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
      }

      .nav-btn {
        background-color: rgba(52, 73, 94, 0.7);
        color: white;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
      }

      .nav-btn:hover {
        background-color: rgba(52, 73, 94, 0.9);
      }

      /* 元素样式 */
      .text-element {
        padding: 15px;
        border-radius: 5px;
      }

      .text-element h3 {
        margin-bottom: 10px;
        color: #2c3e50;
      }

      .text-element p {
        line-height: 1.6;
        color: #34495e;
      }

      .chart-container {
        height: 300px;
        border-radius: 5px;
        background-color: #f8f9fa;
        padding: 15px;
      }

      .image-element {
        text-align: center;
      }

      .image-element img {
        max-width: 100%;
        border-radius: 5px;
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
      }

      .list-element {
        padding: 15px;
        border-radius: 5px;
        background-color: #f8f9fa;
      }

      .list-element ul {
        padding-left: 20px;
      }

      .list-element li {
        margin-bottom: 10px;
        line-height: 1.6;
      }

      /* 编辑模式样式 */
      .editable {
        outline: 2px dashed #3498db;
        padding: 5px;
        margin: 5px;
        position: relative;
      }

      .selected {
        outline: 2px solid #e74c3c;
      }

      .dragging {
        opacity: 0.8;
        z-index: 1000;
      }

      .element-controls {
        position: absolute;
        top: -8px;
        left: -8px;
        right: -8px;
        bottom: -8px;
        pointer-events: none;
        z-index: 10;
      }

      .control-point {
        position: absolute;
        width: 12px;
        height: 12px;
        background: var(--primary-color);
        border: 2px solid white;
        pointer-events: all;
        cursor: pointer;
        border-radius: 2px;
      }

      .resize-tl {
        top: -6px;
        left: -6px;
        cursor: nw-resize;
      }
      .resize-tr {
        top: -6px;
        right: -6px;
        cursor: ne-resize;
      }
      .resize-bl {
        bottom: -6px;
        left: -6px;
        cursor: sw-resize;
      }
      .resize-br {
        bottom: -6px;
        right: -6px;
        cursor: se-resize;
      }

      .rotate {
        top: -25px;
        left: 50%;
        transform: translateX(-50%);
        cursor: crosshair;
        border-radius: 50%;
        background: var(--accent-color);
      }

      .delete {
        top: -25px;
        right: -6px;
        cursor: pointer;
        background: #e74c3c;
        color: white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        line-height: 1;
        font-weight: bold;
      }

      /* 工具栏 */
      .toolbar {
        display: flex;
        padding: 10px;
        background: #ecf0f1;
        border-bottom: 1px solid #bdc3c7;
        gap: 10px;
      }

      .toolbar-btn {
        padding: 8px 15px;
        background: var(--primary-color);
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }

      .toolbar-btn:hover {
        background: #2980b9;
      }

      /* 全屏模式 */
      body.fullscreen {
        overflow: hidden;
      }

      body.fullscreen #sidebar {
        transform: translateX(-100%);
      }

      body.fullscreen #main-content {
        width: 100%;
        height: 100vh;
        margin: 0;
        padding: 0;
      }

      /* 修改全屏模式下的幻灯片样式 */
      body.fullscreen .slide {
        /* 移除边框和阴影以获得更干净的全屏体验 */
        border: none !important;
        box-shadow: none !important;
        /* 移除max-width/max-height限制 */
        max-width: none !important;
        max-height: none !important;
      }

      /* 修改演示区域在全屏时的样式 */
      body.fullscreen #presentation-area {
    background-color: #000 !important;
    margin: 0;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    position: relative;
}

      /* 元素添加面板 */
      .element-panel {
        position: absolute;
        top: 60px;
        left: 20px;
        background: white;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        padding: 15px;
        z-index: 50;
        display: none;
      }

      .element-panel.show {
        display: block;
      }

      .element-type {
        padding: 10px 15px;
        margin: 5px 0;
        background: #ecf0f1;
        border-radius: 4px;
        cursor: pointer;
        transition: background 0.2s;
      }

      .element-type:hover {
        background: #d5dbdb;
      }

      /* 上下文菜单 */
      .context-menu {
        position: absolute;
        background: white;
        border-radius: 4px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        display: none;
      }

      .context-menu.show {
        display: block;
      }

      .context-item {
        padding: 8px 15px;
        cursor: pointer;
        transition: background 0.2s;
      }

      .context-item:hover {
        background: #f0f0f0;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <!-- 侧边栏 -->
      <div id="sidebar">
        <div class="logo">SU3PT</div>

        <div class="mode-toggle">
          <div class="mode-btn active" id="present-mode">放映模式</div>
          <div class="mode-btn" id="edit-mode">修改模式</div>
        </div>

        <div class="slide-list" id="slide-list">
          <!-- 幻灯片列表将通过JS动态生成 -->
        </div>

        <div class="action-buttons">
          <button class="primary-btn" id="add-slide">添加幻灯片</button>
          <button class="secondary-btn" id="delete-slide">
            删除当前幻灯片
          </button>
          <button class="save-btn" id="save-ppt">保存为PPT</button>
          <!-- 添加导入JSON按钮 -->
          <button
            class="primary-btn"
            id="import-json"
            style="background: #9b59b6"
          >
            导入JSON设计
          </button>
          <!-- 添加导出JSON按钮 -->
          <button
            class="export-btn"
            id="export-json"
          >
            导出JSON设计
          </button>
        </div>
      </div>

      <!-- 主内容区 -->
      <div id="main-content">
        <div class="toolbar" id="toolbar" style="display: none">
          <button class="toolbar-btn" id="add-text">添加文本</button>
          <button class="toolbar-btn" id="add-image">添加图片</button>
          <button class="toolbar-btn" id="add-chart">添加图表</button>
          <button class="toolbar-btn" id="add-list">添加列表</button>
        </div>

        <div id="presentation-area">
          <!-- 幻灯片将通过JS动态生成 -->
        </div>

        <div class="nav-buttons">
          <div class="nav-btn" id="prev-slide">上一页</div>
          <div class="nav-btn" id="next-slide">下一页</div>
          <div class="nav-btn" id="fullscreen">全屏</div>
        </div>
      </div>

      <!-- 元素添加面板 -->
      <div class="element-panel" id="element-panel">
        <div class="element-type" data-type="text">文本</div>
        <div class="element-type" data-type="image">图片</div>
        <div class="element-type" data-type="chart">图表</div>
        <div class="element-type" data-type="list">列表</div>
      </div>

      <!-- 上下文菜单 -->
      <div class="context-menu" id="context-menu">
        <div class="context-item" data-action="edit">编辑内容</div>
        <div class="context-item" data-action="duplicate">复制元素</div>
        <div class="context-item" data-action="delete">删除元素</div>
        <div class="context-item" data-action="bring-to-front">置于顶层</div>
        <div class="context-item" data-action="send-to-back">置于底层</div>
      </div>
    </div>

    <script>
      (function () {
          "use strict";

          // ==================== 工具函数 ====================
          function $(selector, context = document) {
              return context.querySelector(selector);
          }

          function $$(selector, context = document) {
              return Array.from(context.querySelectorAll(selector));
          }

          // 全局错误处理
          window.addEventListener("error", (event) => {
              console.error("发生错误:", event.error);
              showNotification("系统发生错误，请刷新页面重试。", "error");
          });

          window.addEventListener("unhandledrejection", (event) => {
              console.error("未处理的Promise拒绝:", event.reason);
              showNotification("操作执行失败，请重试。", "error");
          });

          // 通知函数
          function showNotification(message, type = 'info') {
            // 创建通知元素
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;

            // 设置样式
            notification.style.position = 'fixed';
            notification.style.top = '20px';
            notification.style.right = '20px';
            notification.style.padding = '12px 20px';
            notification.style.borderRadius = '4px';
            notification.style.color = 'white';
            notification.style.fontWeight = 'bold';
            notification.style.zIndex = '9999';
            notification.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.2)';
            notification.style.transition = 'all 0.3s ease';
            notification.style.opacity = '0';

            // 根据类型设置背景色
            switch (type) {
              case 'success':
                notification.style.backgroundColor = '#2ecc71';
                break;
              case 'error':
                notification.style.backgroundColor = '#e74c3c';
                break;
              case 'warning':
                notification.style.backgroundColor = '#f39c12';
                break;
              default:
                notification.style.backgroundColor = '#3498db';
            }

            // 添加到文档
            document.body.appendChild(notification);

            // 显示通知
            setTimeout(() => {
              notification.style.opacity = '1';
            }, 10);

            // 3秒后隐藏并移除
            setTimeout(() => {
              notification.style.opacity = '0';
              setTimeout(() => {
                document.body.removeChild(notification);
              }, 300);
            }, 3000);
          }

          // ==================== 基础元素类 ====================
          class BaseElement {
              constructor(type, content, style = {}) {
                  this.type = type;
                  this.content = content;
                  this.style = style;
                  this.id = "element_" + Date.now() + Math.floor(Math.random() * 1000);
                  this.isSelected = false;
                  this.isDraggable = false;
                  this.isResizable = false;
                  this.position = { x: 100, y: 100 };
                  this.size = { width: 300, height: 200 };
                  this.rotation = 0;
                  this.zIndex = 1;
                  this.element = null;
                  this.dragHandlers = null;
                  this.resizeHandlers = null;
                  this.contentEditableHandlers = [];
                  this.sizeChangeTimeout = null;
              }

              create() {
                  this.element = document.createElement('div');
                  this.element.className = `ppt-element ${this.type}-element`;
                  this.element.id = this.id;

                  // 设置位置和大小
                  this.element.style.left = `${this.position.x}px`;
                  this.element.style.top = `${this.position.y}px`;
                  this.element.style.width = `${this.size.width}px`;
                  this.element.style.height = `${this.size.height}px`;
                  this.element.style.zIndex = this.zIndex;
                  this.element.style.transform = `rotate(${this.rotation}deg)`;
                  this.element.style.position = "absolute";

                  // 应用样式
                  if (this.style) {
                      Object.keys(this.style).forEach(prop => {
                          if (prop in this.element.style) {
                              this.element.style[prop] = this.style[prop];
                          }
                      });
                  }

                  return this.element;
              }

              render() {
                  this.create();
                  this.renderContent();
                  return this.element.outerHTML;
              }

              renderContent() {
                  // 子类需要实现此方法
                  throw new Error('renderContent方法必须由子类实现');
              }

              // ==================== 编辑功能 ====================
              enableEdit() {
                  this.isDraggable = true;
                  this.isResizable = true;
                  this.addEditControls();
                  this.makeDraggable();
                  this.makeContentEditable();
              }

              disableEdit() {
                  this.isDraggable = false;
                  this.isResizable = false;
                  this.removeEditControls();
                  this.disableContentEditable();
              }

              addEditControls() {
                  const element = $(`#${this.id}`);
                  if (!element) return;

                  this.removeEditControls();
                  element.classList.add("editable", "selected");

                  const controlsContainer = document.createElement("div");
                  controlsContainer.className = "element-controls";
                  controlsContainer.innerHTML = `
                      <div class="control-point resize-tl" data-action="resize"></div>
                      <div class="control-point resize-tr" data-action="resize"></div>
                      <div class="control-point resize-bl" data-action="resize"></div>
                      <div class="control-point resize-br" data-action="resize"></div>
                      <div class="control-point rotate" data-action="rotate">⟳</div>
                      <div class="control-point delete" data-action="delete">×</div>
                  `;

                  element.appendChild(controlsContainer);
                  this.bindControlEvents(controlsContainer);
                  this.bindContextMenu(element);
              }

              bindControlEvents(controlsContainer) {
                  const element = document.getElementById(this.id);

                  const deleteBtn = controlsContainer.querySelector(".control-point.delete");
                  deleteBtn.addEventListener("click", (e) => {
                      e.stopPropagation();
                      this.delete();
                  });

                  const rotateBtn = controlsContainer.querySelector(".control-point.rotate");
                  this.bindRotateEvent(rotateBtn, element);

                  const resizePoints = controlsContainer.querySelectorAll('.control-point[data-action="resize"]');
                  resizePoints.forEach((point) => {
                      this.bindResizeEvent(point, element);
                  });
              }

              bindContextMenu(element) {
                  element.addEventListener("contextmenu", (e) => {
                      e.preventDefault();
                      const contextMenu = document.getElementById("context-menu");
                      if (!contextMenu) return;

                      contextMenu.style.left = e.clientX + "px";
                      contextMenu.style.top = e.clientY + "px";
                      contextMenu.classList.add("show");
                      contextMenu.setAttribute("data-element-id", this.id);

                      const closeMenu = () => {
                          contextMenu.classList.remove("show");
                          document.removeEventListener("click", closeMenu);
                      };

                      setTimeout(() => {
                          document.addEventListener("click", closeMenu);
                      }, 100);
                  });
              }

              makeDraggable() {
                  const element = document.getElementById(this.id);
                  if (!element) return;

                  let isDragging = false;
                  let startX, startY, initialLeft, initialTop;

                  const onMouseDown = (e) => {
                      if (e.target.isContentEditable || e.target.closest('[contenteditable="true"]')) {
                          return;
                      }
                      if (!this.isDraggable) return;
                      if (e.target.classList.contains("control-point")) return;

                      isDragging = true;
                      startX = e.clientX;
                      startY = e.clientY;

                      const computedStyle = getComputedStyle(element);
                      initialLeft = parseFloat(computedStyle.left) || 0;
                      initialTop = parseFloat(computedStyle.top) || 0;

                      element.style.zIndex = "1000";
                      element.classList.add("dragging");

                      e.preventDefault();
                      e.stopPropagation();
                  };

                  const onMouseMove = (e) => {
                      if (!isDragging) return;

                      const deltaX = e.clientX - startX;
                      const deltaY = e.clientY - startY;

                      const newLeft = initialLeft + deltaX;
                      const newTop = initialTop + deltaY;

                      element.style.left = `${newLeft}px`;
                      element.style.top = `${newTop}px`;

                      this.position.x = newLeft;
                      this.position.y = newTop;
                  };

                  const onMouseUp = () => {
                      if (!isDragging) return;

                      isDragging = false;
                      element.style.zIndex = this.zIndex.toString();
                      element.classList.remove("dragging");
                      this.onPositionChange();
                  };

                  element.addEventListener("mousedown", onMouseDown);
                  document.addEventListener("mousemove", onMouseMove);
                  document.addEventListener("mouseup", onMouseUp);

                  this.dragHandlers = { onMouseDown, onMouseMove, onMouseUp };
              }

              bindRotateEvent(controlPoint, element) {
                  let isRotating = false;
                  let startAngle, initialAngle;

                  const onMouseDown = (e) => {
                      isRotating = true;
                      const rect = element.getBoundingClientRect();
                      const centerX = rect.left + rect.width / 2;
                      const centerY = rect.top + rect.height / 2;

                      startAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                      initialAngle = this.rotation || 0;

                      e.preventDefault();
                      e.stopPropagation();
                  };

                  const onMouseMove = (e) => {
                      if (!isRotating) return;

                      const rect = element.getBoundingClientRect();
                      const centerX = rect.left + rect.width / 2;
                      const centerY = rect.top + rect.height / 2;

                      const currentAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                      const deltaAngle = currentAngle - startAngle;
                      const newAngle = initialAngle + deltaAngle * (180 / Math.PI);

                      this.rotation = newAngle;
                      element.style.transform = `rotate(${newAngle}deg)`;
                  };

                  const onMouseUp = () => {
                      isRotating = false;
                      this.onRotationChange();
                  };

                  controlPoint.addEventListener("mousedown", onMouseDown);
                  document.addEventListener("mousemove", onMouseMove);
                  document.addEventListener("mouseup", onMouseUp);
              }

              bindResizeEvent(controlPoint, element) {
                  let isResizing = false;
                  let startX, startY, initialWidth, initialHeight, initialLeft, initialTop;
                  let parentPosition = { x: 0, y: 0 };

                  this.resizeHandlers = this.resizeHandlers || {};
                  const handlerKey = controlPoint.dataset.action + "-" + controlPoint.className;

                  if (this.resizeHandlers[handlerKey]) {
                      const { onMouseDown, onMouseMove, onMouseUp } = this.resizeHandlers[handlerKey];
                      controlPoint.removeEventListener("mousedown", onMouseDown);
                      document.removeEventListener("mousemove", onMouseMove);
                      document.removeEventListener("mouseup", onMouseUp);
                  }

                  const onMouseDown = (e) => {
                      isResizing = true;
                      startX = e.clientX;
                      startY = e.clientY;

                      const rect = element.getBoundingClientRect();
                      initialWidth = rect.width;
                      initialHeight = rect.height;
                      initialLeft = rect.left;
                      initialTop = rect.top;

                      const parentRect = element.parentElement.getBoundingClientRect();
                      parentPosition.x = parentRect.left;
                      parentPosition.y = parentRect.top;

                      e.preventDefault();
                      e.stopPropagation();
                  };

                  const onMouseMove = (e) => {
                      if (!isResizing) return;

                      const deltaX = e.clientX - startX;
                      const deltaY = e.clientY - startY;

                      const isRight = controlPoint.classList.contains("resize-tr") || controlPoint.classList.contains("resize-br");
                      const isBottom = controlPoint.classList.contains("resize-bl") || controlPoint.classList.contains("resize-br");
                      const isLeft = controlPoint.classList.contains("resize-tl") || controlPoint.classList.contains("resize-bl");
                      const isTop = controlPoint.classList.contains("resize-tl") || controlPoint.classList.contains("resize-tr");

                      let newWidth = initialWidth;
                      let newHeight = initialHeight;
                      let newLeft = initialLeft;
                      let newTop = initialTop;

                      if (isRight) newWidth = Math.max(10, initialWidth + deltaX);
                      if (isLeft) {
                          newWidth = Math.max(10, initialWidth - deltaX);
                          newLeft = initialLeft + deltaX;
                      }
                      if (isBottom) newHeight = Math.max(10, initialHeight + deltaY);
                      if (isTop) {
                          newHeight = Math.max(10, initialHeight - deltaY);
                          newTop = initialTop + deltaY;
                      }

                      const parentRect = element.parentElement.getBoundingClientRect();
                      const parentStyle = window.getComputedStyle(element.parentElement);
                      const parentPaddingLeft = parseInt(parentStyle.paddingLeft) || 0;
                      const parentPaddingTop = parseInt(parentStyle.paddingTop) || 0;
                      
                      // 计算相对于父容器的位置（考虑padding）
                      const parentPosition = {
                          x: parentRect.left + parentPaddingLeft,
                          y: parentRect.top + parentPaddingTop
                      };
                      
                      // 只限制元素不超出父容器内容区域
                      newLeft = Math.max(parentPaddingLeft, newLeft);
                      newTop = Math.max(parentPaddingTop, newTop);
                      
                      element.style.width = `${newWidth}px`;
                      element.style.height = `${newHeight}px`;
                      element.style.left = `${newLeft}px`;
                      element.style.top = `${newTop}px`;
                      
                      // 保存相对于父容器的位置（减去padding）
                      this.size.width = newWidth;
                      this.size.height = newHeight;
                      this.position.x = newLeft - parentPaddingLeft;
                      this.position.y = newTop - parentPaddingTop;
                  };

                  const onMouseUp = () => {
                      if (!isResizing) return;
                      isResizing = false;
                      this.onSizeChange();
                  };

                  controlPoint.addEventListener("mousedown", onMouseDown);
                  document.addEventListener("mousemove", onMouseMove);
                  document.addEventListener("mouseup", onMouseUp);

                  this.resizeHandlers[handlerKey] = { onMouseDown, onMouseMove, onMouseUp };
              }

              removeEditControls() {
                  const element = $(`#${this.id}`);
                  if (!element) return;

                  element.classList.remove("editable", "selected", "dragging");

                  const controls = element.querySelector(".element-controls");
                  if (controls) {
                      controls.remove();
                  }

                  if (this.dragHandlers) {
                      element.removeEventListener("mousedown", this.dragHandlers.onMouseDown);
                      document.removeEventListener("mousemove", this.dragHandlers.onMouseMove);
                      document.removeEventListener("mouseup", this.dragHandlers.onMouseUp);
                      this.dragHandlers = null;
                  }

                  if (this.contentEditableHandlers) {
                      element.querySelectorAll('[contenteditable="true"]').forEach((el) => {
                          this.contentEditableHandlers.forEach((handler) => {
                              el.removeEventListener("blur", handler);
                          });
                      });
                      this.contentEditableHandlers = [];
                  }
              }

              makeContentEditable() {
                  // 默认实现，子类可以重写
              }

              disableContentEditable() {
                  const element = $(`#${this.id}`);
                  if (element) {
                      const editableElements = element.querySelectorAll('[contenteditable="true"]');
                      editableElements.forEach(el => {
                          el.setAttribute("contenteditable", "false");
                      });
                  }
              }

              delete() {
                  if (confirm("确定要删除这个元素吗？")) {
                      const element = $(`#${this.id}`);
                      if (element) {
                          this.removeEditControls();
                          element.remove();
                      }
                      this.onDelete();
                      return true;
                  }
                  return false;
              }

              updateContent(newContent) {
                  this.content = { ...this.content, ...newContent };
                  this.updateElement();
                  if (window.pptManager) {
                    window.pptManager.saveToLocalStorage();
                }
              }

              updateStyle(newStyle) {
                  this.style = { ...this.style, ...newStyle };
                  this.updateElement();
              }

              updateElement() {
                  const element = document.getElementById(this.id);
                  if (element) {
                      // 直接更新现有元素，而不是重新创建
                      element.style.left = `${this.position.x}px`;
                      element.style.top = `${this.position.y}px`;
                      element.style.width = `${this.size.width}px`;
                      element.style.height = `${this.size.height}px`;
                      element.style.transform = `rotate(${this.rotation}deg)`;
                      element.style.zIndex = this.zIndex;
                      
                      if (this.isDraggable) {
                          setTimeout(() => this.enableEdit(), 0);
                      }
                  }
              }

              duplicate() {
                  const newElement = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
                  newElement.id = "element_" + Date.now() + Math.floor(Math.random() * 1000);
                  newElement.position.x += 20;
                  newElement.position.y += 20;
                  return newElement;
              }

              bringToFront() {
                  this.zIndex = 1000;
                  const element = document.getElementById(this.id);
                  if (element) {
                      element.style.zIndex = this.zIndex;
                  }
              }

              sendToBack() {
                  this.zIndex = 1;
                  const element = document.getElementById(this.id);
                  if (element) {
                      element.style.zIndex = this.zIndex;
                  }
              }

              onPositionChange() {
                  if (window.pptManager) {
                      window.pptManager.saveToLocalStorage();
                  }
              }

              onRotationChange() {
                  if (window.pptManager) {
                      window.pptManager.saveToLocalStorage();
                  }
              }

              onSizeChange() {
                  if (this.sizeChangeTimeout) {
                      clearTimeout(this.sizeChangeTimeout);
                  }
                  this.sizeChangeTimeout = setTimeout(() => {
                      if (window.pptManager) {
                          window.pptManager.saveToLocalStorage();
                      }
                  }, 300);
              }

              onDelete() {
                  if (window.pptManager) {
                      window.pptManager.saveToLocalStorage();
                  }
              }

              getState() {
                  return {
                      type: this.type,
                      content: this.content,
                      style: this.style,
                      position: this.position,
                      size: this.size,
                      rotation: this.rotation,
                      zIndex: this.zIndex,
                      id: this.id,
                  };
              }

              setState(state) {
                  this.content = state.content;
                  this.style = state.style;
                  this.position = state.position;
                  this.size = state.size;
                  this.rotation = state.rotation;
                  this.zIndex = state.zIndex;
                  this.id = state.id;
                  this.updateElement();
              }
          }

          // ==================== 具体元素类实现 ====================

          // 文本元素类
          class TextElement extends BaseElement {
              constructor(content, style = {}) {
                  super("text", content, style);
              }

              renderContent() {
                  if (this.content.title) {
                      const title = document.createElement('div');
                      title.className = 'text-title';
                      title.textContent = this.content.title;
                      title.style.color = this.style.color || '#000';
                      title.style.fontSize = this.style.fontSize || '24px';
                      title.style.fontWeight = this.style.fontWeight || 'bold';
                      title.style.textAlign = this.style.textAlign || 'left';
                      title.style.marginBottom = '10px';
                      this.element.appendChild(title);
                  }

                  if (this.content.body) {
                      const body = document.createElement('div');
                      body.className = 'text-body';
                      body.textContent = this.content.body;
                      body.style.color = this.style.color || '#000';
                      body.style.fontSize = this.style.bodyFontSize || '16px';
                      body.style.lineHeight = '1.5';
                      this.element.appendChild(body);
                  }
              }

              makeContentEditable() {
                  const element = $(`#${this.id}`);
                  if (element) {
                      const titles = element.querySelectorAll(".text-title");
                      const bodies = element.querySelectorAll(".text-body");

                      const setupEditable = (el, property) => {
                          el.setAttribute("contenteditable", "true");

                          const inputHandler = () => {
                              this.content[property] = el.textContent || "";
                          };

                          const blurHandler = () => {
                              this.content[property] = el.textContent || "";
                              if (window.pptManager) {
                                  window.pptManager.saveToLocalStorage();
                              }
                          };

                          el.addEventListener("input", inputHandler);
                          el.addEventListener("blur", blurHandler);

                          this.contentEditableHandlers.push(() => {
                              el.removeEventListener("input", inputHandler);
                              el.removeEventListener("blur", blurHandler);
                          });
                      };

                      titles.forEach(title => setupEditable(title, 'title'));
                      bodies.forEach(body => setupEditable(body, 'body'));
                  }
              }

              setFontSize(elementType, size) {
                  if (elementType === "title") {
                      this.style.fontSize = size;
                  } else if (elementType === "body") {
                      this.style.bodyFontSize = size;
                  }
                  this.updateElement();
              }
          }

          // 图片元素类
          class ImageElement extends BaseElement {
              constructor(content, style = {}) {
                  super("image", content, style);
              }

              renderContent() {
                  const img = document.createElement('img');
                  img.src = this.content.src || this.content.url || 'https://via.placeholder.com/400x300';
                  img.alt = this.content.alt || '图片';
                  
                  img.style.width = '100%';
                  img.style.height = '100%';
                  
                  this.element.innerHTML = '';
                  this.element.appendChild(img);
                  
                  if (!this.content.originalSize && img.complete) {
                      this.setOriginalSize(img);
                  } else if (!this.content.originalSize) {
                      img.onload = () => {
                          this.setOriginalSize(img);
                      };
                  }
              }
              
              // 设置图片原始尺寸的方法
              setOriginalSize(img) {
                  this.content.originalSize = { width: img.naturalWidth, height: img.naturalHeight };
                  
                  if (!this.content.hasBeenEdited) {
                      const slideWidth = 1024;
                      const slideHeight = 576;
                      const padding = 40;
                      const availableWidth = slideWidth - padding * 2;
                      const availableHeight = slideHeight - padding * 2;
                      
                      const widthScale = availableWidth / img.naturalWidth;
                      const heightScale = availableHeight / img.naturalHeight;
                      const scale = Math.min(widthScale, heightScale);
                      
                      this.size = {
                          width: Math.round(img.naturalWidth * scale),
                          height: Math.round(img.naturalHeight * scale)
                      };
                      
                      const element = document.getElementById(this.id);
                      if (element) {
                          element.style.width = `${this.size.width}px`;
                          element.style.height = `${this.size.height}px`;
                      }
                      
                      this.content.hasBeenEdited = true;
                  }
              }
              
              // 覆盖父类的bindResizeEvent方法，实现图片元素的等比例缩放
              bindResizeEvent(controlPoint, element) {
                  let isResizing = false;
                  let startX, startY, initialWidth, initialHeight, initialLeft, initialTop;
                  let parentPosition = { x: 0, y: 0 };
                  
                  const aspectRatio = this.content.originalSize ? 
                      this.content.originalSize.width / this.content.originalSize.height : 16/9;
                  
                  const slideWidth = 1024;
                  const slideHeight = 576;
                  const padding = 40;
                  const availableWidth = slideWidth - padding * 2;
                  const availableHeight = slideHeight - padding * 2;
                  
                  this.resizeHandlers = this.resizeHandlers || {};
                  const handlerKey = controlPoint.dataset.action + "-" + controlPoint.className;
                  
                  if (this.resizeHandlers[handlerKey]) {
                      const { onMouseDown, onMouseMove, onMouseUp } = this.resizeHandlers[handlerKey];
                      controlPoint.removeEventListener("mousedown", onMouseDown);
                      document.removeEventListener("mousemove", onMouseMove);
                      document.removeEventListener("mouseup", onMouseUp);
                  }
                  
                  const onMouseDown = (e) => {
                      isResizing = true;
                      startX = e.clientX;
                      startY = e.clientY;
                      
                      const rect = element.getBoundingClientRect();
                      initialWidth = rect.width;
                      initialHeight = rect.height;
                      initialLeft = rect.left;
                      initialTop = rect.top;
                      
                      const parentRect = element.parentElement.getBoundingClientRect();
                      parentPosition.x = parentRect.left;
                      parentPosition.y = parentRect.top;
                      
                      e.preventDefault();
                      e.stopPropagation();
                  };
                  
                  const onMouseMove = (e) => {
                      if (!isResizing) return;
                      
                      const deltaX = e.clientX - startX;
                      const deltaY = e.clientY - startY;
                      
                      const isRight = controlPoint.classList.contains("resize-tr") || controlPoint.classList.contains("resize-br");
                      const isBottom = controlPoint.classList.contains("resize-bl") || controlPoint.classList.contains("resize-br");
                      const isLeft = controlPoint.classList.contains("resize-tl") || controlPoint.classList.contains("resize-bl");
                      const isTop = controlPoint.classList.contains("resize-tl") || controlPoint.classList.contains("resize-tr");
                      
                      let newWidth = initialWidth;
                      let newHeight = initialHeight;
                      let newLeft = initialLeft;
                      let newTop = initialTop;
                      
                      const isCorner = (isRight || isLeft) && (isTop || isBottom);
                      
                      if (isCorner) {
                          const widthChange = isRight ? deltaX : -deltaX;
                          const heightChange = isBottom ? deltaY : -deltaY;
                          
                          const widthScale = (initialWidth + widthChange) / initialWidth;
                          const heightScale = (initialHeight + heightChange) / initialHeight;
                          
                          const scale = Math.max(widthScale, heightScale);
                          
                          newWidth = Math.max(10, initialWidth * scale);
                          newHeight = newWidth / aspectRatio;
                          
                          if (isLeft) newLeft = initialLeft + (initialWidth - newWidth);
                          if (isTop) newTop = initialTop + (initialHeight - newHeight);
                      } else if (isRight || isLeft) {
                          if (isRight) newWidth = Math.max(10, initialWidth + deltaX);
                          if (isLeft) {
                              newWidth = Math.max(10, initialWidth - deltaX);
                              newLeft = initialLeft + deltaX;
                          }
                          newHeight = newWidth / aspectRatio;
                      } else if (isBottom || isTop) {
                          if (isBottom) newHeight = Math.max(10, initialHeight + deltaY);
                          if (isTop) {
                              newHeight = Math.max(10, initialHeight - deltaY);
                              newTop = initialTop + deltaY;
                          }
                          newWidth = newHeight * aspectRatio;
                      }
                      
                      const parentRect = element.parentElement.getBoundingClientRect();
                      const relativeLeft = newLeft - parentPosition.x;
                      const relativeTop = newTop - parentPosition.y;
                      
                      const maxLeft = availableWidth - newWidth;
                      const maxTop = availableHeight - newHeight;
                      
                      newLeft = Math.max(parentPosition.x, Math.min(parentPosition.x + maxLeft, newLeft));
                      newTop = Math.max(parentPosition.y, Math.min(parentPosition.y + maxTop, newTop));
                      
                      element.style.width = `${newWidth}px`;
                      element.style.height = `${newHeight}px`;
                      element.style.left = `${newLeft - parentPosition.x}px`;
                      element.style.top = `${newTop - parentPosition.y}px`;
                      
                      this.size.width = newWidth;
                      this.size.height = newHeight;
                      this.position.x = newLeft - parentPosition.x;
                      this.position.y = newTop - parentPosition.y;
                  };
                  
                  const onMouseUp = () => {
                      if (!isResizing) return;
                      isResizing = false;
                      this.onSizeChange();
                  };
                  
                  controlPoint.addEventListener("mousedown", onMouseDown);
                  document.addEventListener("mousemove", onMouseMove);
                  document.addEventListener("mouseup", onMouseUp);
                  
                  this.resizeHandlers[handlerKey] = { onMouseDown, onMouseMove, onMouseUp };
              }

              // 添加图片编辑功能
              enableEdit() {
                  super.enableEdit();
                  const element = document.getElementById(this.id);
                  if (element) {
                      const img = element.querySelector('img');
                      if (img) {
                          img.addEventListener('dblclick', this.handleImageDoubleClick.bind(this));
                      }
                  }
              }

              disableEdit() {
                  super.disableEdit();
                  const element = document.getElementById(this.id);
                  if (element) {
                      const img = element.querySelector('img');
                      if (img) {
                          img.removeEventListener('dblclick', this.handleImageDoubleClick.bind(this));
                      }
                  }
              }

              // 双击图片时允许替换图片
              handleImageDoubleClick() {
                  const input = document.createElement('input');
                  input.type = 'file';
                  input.accept = 'image/*';
                  input.onchange = (e) => {
                      const file = e.target.files[0];
                      if (file) {
                          const reader = new FileReader();
                          reader.onload = (event) => {
                              this.content.src = event.target.result;
                              // 重置编辑状态，以便重新计算尺寸
                              this.content.hasBeenEdited = false;
                              this.updateElement();
                              showNotification('图片已更新', 'success');
                          };
                          reader.readAsDataURL(file);
                      }
                  };
                  input.click();
              }
          }

          // 图表元素类
          class ChartElement extends BaseElement {
              constructor(content, style = {}) {
                  super('chart', content, style);
                  this.chartInstance = null;
              }

              renderContent() {
                  this.element.innerHTML = `
                    <div class="chart-container">
                        <div id="chart_${this.id}" style="width: 100%; height: 100%;"></div>
                    </div>
                    `;
              }

              renderChart() {
                  try {
                    const chartContainer = document.getElementById(`chart_${this.id}`);
                    if (!chartContainer) {
                      console.error('图表容器未找到');
                      return;
                    }

                    // 销毁已存在的图表实例
                    if (this.chartInstance) {
                      this.chartInstance.dispose();
                      this.chartInstance = null;
                    }

                    // 创建新的图表实例
                    this.chartInstance = echarts.init(chartContainer);

                    // 获取图表配置
                    let chartOption = this.content.chartOption || {
                      title: { text: '默认图表' },
                      tooltip: {},
                      xAxis: { data: ['A', 'B', 'C', 'D', 'E'] },
                      yAxis: {},
                      series: [
                        { name: '数据', type: 'bar', data: [10, 20, 15, 25, 18] }
                      ]
                    };

                    // 对图表数据进行智能处理 - 自动识别x轴数据类型
                    if (chartOption.xAxis && chartOption.xAxis.data && chartOption.xAxis.data.length > 0) {
                      const totalCount = chartOption.xAxis.data.length;
                      let numericCount = 0;

                      chartOption.xAxis.data.forEach((item) => {
                        if (!isNaN(parseFloat(item)) && isFinite(item)) {
                          numericCount++;
                        }
                      });

                      // 如果超过70%的数据是数字，则优化x轴显示
                      if (numericCount / totalCount > 0.7 && totalCount > 0) {
                        // 保存原始数据作为刻度标签
                        const originalLabels = [...chartOption.xAxis.data];

                        // 设置x轴，确保标签正确显示
                        chartOption.xAxis = {
                          type: 'category',
                          data: originalLabels,
                          axisLabel: {
                            formatter: function (value, index) {
                              return originalLabels[index];
                            }
                          }
                        };
                      }
                    }

                    // 设置图表选项
                    this.chartInstance.setOption(chartOption);

                    // 窗口大小变化时重新调整图表
                    window.addEventListener('resize', this.handleResize.bind(this));

                  } catch (error) {
                    console.error('渲染图表时出错:', error);
                  }
              }

              handleResize() {
    if (document.fullscreenElement) {
        this.adjustSlideForFullscreen();
    } else {
        // 确保非全屏状态下幻灯片正确居中
        const slide = document.querySelector('.slide.active');
        if (slide) {
            slide.style.position = 'absolute';
            slide.style.left = '50%';
            slide.style.top = '50%';
            slide.style.marginLeft = `-512px`;
            slide.style.marginTop = `-288px`;
            slide.style.width = '1024px';
            slide.style.height = '576px';
            slide.style.transform = 'none';
        }
    }
}

              onDelete() {
                  if (this.chartInstance) {
                      this.chartInstance.dispose();
                      this.chartInstance = null;
                  }
                  // 移除事件监听器
                  window.removeEventListener('resize', this.handleResize.bind(this));
                  super.onDelete();
              }

              onSizeChange() {
                  super.onSizeChange();
                  // 图表尺寸变化后重新渲染
                  setTimeout(() => this.renderChart(), 100);
              }
          }

          // 列表元素类
          class ListElement extends BaseElement {
              constructor(content, style = {}) {
                  super("list", content, style);
              }

              renderContent() {
                  if (this.content.title) {
                      const title = document.createElement('div');
                      title.className = 'list-title';
                      title.textContent = this.content.title;
                      title.style.fontSize = '20px';
                      title.style.fontWeight = 'bold';
                      title.style.marginBottom = '15px';
                      this.element.appendChild(title);
                  }

                  if (this.content.items && this.content.items.length > 0) {
                      const list = document.createElement('ul');
                      list.className = 'list-items';
                      list.style.margin = '0';
                      list.style.paddingLeft = '20px';

                      this.content.items.forEach((item, index) => {
                          const listItem = document.createElement('li');
                          listItem.className = 'list-item';
                          listItem.textContent = typeof item === 'string' ? item : (item.text || '');
                          listItem.style.marginBottom = '8px';
                          listItem.style.padding = '5px';
                          listItem.dataset.index = index;
                          list.appendChild(listItem);
                      });

                      this.element.appendChild(list);
                  }
              }

              makeContentEditable() {
                  const element = $(`#${this.id}`);
                  if (element) {
                      const title = element.querySelector(".list-title");
                      const items = element.querySelectorAll(".list-item");

                      if (title) {
                          title.setAttribute("contenteditable", "true");
                          const titleHandler = () => {
                              this.content.title = title.textContent || "";
                              if (window.pptManager) {
                                  window.pptManager.saveToLocalStorage();
                              }
                          };
                          title.addEventListener("blur", titleHandler);
                          this.contentEditableHandlers.push(() => {
                              title.removeEventListener("blur", titleHandler);
                          });
                      }

                      items.forEach((item) => {
                          item.setAttribute("contenteditable", "true");
                          const index = parseInt(item.dataset.index);
                          const itemHandler = () => {
                              if (!this.content.items) this.content.items = [];
                              this.content.items[index] = item.textContent || "";
                              if (window.pptManager) {
                                  window.pptManager.saveToLocalStorage();
                              }
                          };
                          item.addEventListener("blur", itemHandler);
                          this.contentEditableHandlers.push(() => {
                              item.removeEventListener("blur", itemHandler);
                          });
                      });
                  }
              }
          }

          // 背景元素类
          class BackgroundElement extends BaseElement {
              constructor(content, style = {}) {
                  super("background", content, style);
                  this.zIndex = -1;
              }

              renderContent() {
                  this.element.style.background = this.content.background || "#ffffff";
                  this.element.style.left = "0";
                  this.element.style.top = "0";
                  this.element.style.width = "100%";
                  this.element.style.height = "100%";
                  this.element.style.zIndex = this.zIndex;
              }

              addEditControls() {
                  const element = $(`#${this.id}`);
                  if (!element) return;

                  element.classList.add("editable", "selected");

                  const controlsContainer = document.createElement("div");
                  controlsContainer.className = "element-controls";
                  controlsContainer.innerHTML = `
                      <div class="control-point delete" data-action="delete">×</div>
                  `;

                  element.appendChild(controlsContainer);

                  const deleteBtn = controlsContainer.querySelector(".control-point.delete");
                  deleteBtn.addEventListener("click", (e) => {
                      e.stopPropagation();
                      this.delete();
                  });

                  this.bindContextMenu(element);
              }

              makeDraggable() {
                  // 背景通常不需要拖拽
              }

              bindResizeEvent() {
                  // 背景通常不需要缩放
              }
          }

          // ==================== 自定义元素类 ====================

          // 渐变面板元素类
          class GradientPanelElement extends BaseElement {
              constructor(content, style = {}) {
                  super("gradient-panel", content, style);
              }

              renderContent() {
                  this.element.style.background = `linear-gradient(145deg, ${this.content.color1}, ${this.content.color2})`;
                  this.element.style.borderRadius = '12px';
                  this.element.style.padding = '20px';
                  this.element.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.1)';

                  if (this.content.title) {
                      const title = document.createElement('div');
                      title.className = 'gradient-title';
                      title.textContent = this.content.title;
                      title.style.color = this.content.textColor || '#FFFFFF';
                      title.style.fontSize = '20px';
                      title.style.fontWeight = 'bold';
                      title.style.marginBottom = '15px';
                      this.element.appendChild(title);
                  }

                  if (this.content.content) {
                      const body = document.createElement('div');
                      body.className = 'gradient-content';
                      body.textContent = this.content.content;
                      body.style.color = this.content.textColor || '#FFFFFF';
                      body.style.fontSize = '16px';
                      body.style.lineHeight = '1.6';
                      body.style.opacity = '0.9';
                      this.element.appendChild(body);
                  }
              }

              makeContentEditable() {
                  const element = $(`#${this.id}`);
                  if (element) {
                      const title = element.querySelector(".gradient-title");
                      const content = element.querySelector(".gradient-content");

                      if (title) {
                          title.setAttribute("contenteditable", "true");
                          const titleHandler = () => {
                              this.content.title = title.textContent || "";
                              if (window.pptManager) {
                                  window.pptManager.saveToLocalStorage();
                              }
                          };
                          title.addEventListener("blur", titleHandler);
                          this.contentEditableHandlers.push(() => {
                              title.removeEventListener("blur", titleHandler);
                          });
                      }

                      if (content) {
                          content.setAttribute("contenteditable", "true");
                          const contentHandler = () => {
                              this.content.content = content.textContent || "";
                              if (window.pptManager) {
                                  window.pptManager.saveToLocalStorage();
                              }
                          };
                          content.addEventListener("blur", contentHandler);
                          this.contentEditableHandlers.push(() => {
                              content.removeEventListener("blur", contentHandler);
                          });
                      }
                  }
              }
          }

          // 进度环元素类
          class ProgressRingElement extends BaseElement {
              constructor(content, style = {}) {
                  super("progress-ring", content, style);
              }

              renderContent() {
                  const content = this.content;
                  const size = content.size || 100;
                  const value = content.value || 0;
                  const dashValue = (value / 100) * 283; // 圆周长度 2πr ≈ 283

                  const container = document.createElement('div');
                  container.style.display = 'flex';
                  container.style.flexDirection = 'column';
                  container.style.alignItems = 'center';
                  container.style.justifyContent = 'center';
                  container.style.width = '100%';
                  container.style.height = '100%';

                  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                  svg.setAttribute('width', size);
                  svg.setAttribute('height', size);
                  svg.setAttribute('viewBox', '0 0 100 100');

                  // 背景圆环
                  const track = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                  track.setAttribute('cx', '50');
                  track.setAttribute('cy', '50');
                  track.setAttribute('r', '45');
                  track.setAttribute('stroke', content.trackColor || '#e0e0e0');
                  track.setAttribute('fill', 'none');
                  track.setAttribute('stroke-width', '8');

                  // 进度圆环
                  const progress = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                  progress.setAttribute('cx', '50');
                  progress.setAttribute('cy', '50');
                  progress.setAttribute('r', '45');
                  progress.setAttribute('stroke', content.progressColor || '#3B82F6');
                  progress.setAttribute('fill', 'none');
                  progress.setAttribute('stroke-width', '8');
                  progress.setAttribute('stroke-dasharray', `${dashValue}, 283`);
                  progress.setAttribute('transform', 'rotate(-90 50 50)');
                  progress.setAttribute('stroke-linecap', 'round');

                  svg.appendChild(track);
                  svg.appendChild(progress);

                  const text = document.createElement('div');
                  text.textContent = `${value}%`;
                  text.style.color = content.textColor || '#000';
                  text.style.fontSize = '18px';
                  text.style.marginTop = '15px';
                  text.style.fontWeight = 'bold';

                  container.appendChild(svg);
                  container.appendChild(text);
                  this.element.appendChild(container);
              }
          }

          // 技术栈元素类
          class TechStackElement extends BaseElement {
              constructor(content, style = {}) {
                  super("tech-stack", content, style);
              }

              renderContent() {
                  this.element.style.background = `linear-gradient(145deg, ${this.content.color1}, ${this.content.color2})`;
                  this.element.style.borderRadius = '12px';
                  this.element.style.padding = '25px';
                  this.element.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.1)';

                  if (this.content.title) {
                      const title = document.createElement('div');
                      title.className = 'tech-title';
                      title.textContent = this.content.title;
                      title.style.color = this.content.textColor || '#FFFFFF';
                      title.style.fontSize = '22px';
                      title.style.fontWeight = 'bold';
                      title.style.marginBottom = '20px';
                      title.style.textAlign = 'center';
                      this.element.appendChild(title);
                  }

                  if (this.content.content) {
                      const body = document.createElement('div');
                      body.className = 'tech-content';
                      body.textContent = this.content.content;
                      body.style.color = `${this.content.textColor}99` || 'rgba(255,255,255,0.6)';
                      body.style.fontSize = '16px';
                      body.style.lineHeight = '1.8';
                      body.style.textAlign = 'center';
                      this.element.appendChild(body);
                  }
              }

              makeContentEditable() {
                  const element = $(`#${this.id}`);
                  if (element) {
                      const title = element.querySelector(".tech-title");
                      const content = element.querySelector(".tech-content");

                      if (title) {
                          title.setAttribute("contenteditable", "true");
                          const titleHandler = () => {
                              this.content.title = title.textContent || "";
                              if (window.pptManager) {
                                  window.pptManager.saveToLocalStorage();
                              }
                          };
                          title.addEventListener("blur", titleHandler);
                          this.contentEditableHandlers.push(() => {
                              title.removeEventListener("blur", titleHandler);
                          });
                      }

                      if (content) {
                          content.setAttribute("contenteditable", "true");
                          const contentHandler = () => {
                              this.content.content = content.textContent || "";
                              if (window.pptManager) {
                                  window.pptManager.saveToLocalStorage();
                              }
                          };
                          content.addEventListener("blur", contentHandler);
                          this.contentEditableHandlers.push(() => {
                              content.removeEventListener("blur", contentHandler);
                          });
                      }
                  }
              }
          }

          // ==================== 元素注册表 ====================
          class ElementRegistry {
              static customElements = new Map();

              static registerElementType(typeName, elementClass) {
                  this.customElements.set(typeName, elementClass);
                  console.log(`已注册元素类型: ${typeName}`);
              }

              static createElement(type, content, style = {}) {
                  // 首先检查自定义元素
                  if (this.customElements.has(type)) {
                      const ElementClass = this.customElements.get(type);
                      return new ElementClass(content, style);
                  }

                  // 基础元素类型
                  switch (type) {
                      case "text":
                          return new TextElement(content, style);
                      case "image":
                          return new ImageElement(content, style);
                      case "chart":
                          return new ChartElement(content, style);
                      case "list":
                          return new ListElement(content, style);
                      case "background":
                          return new BackgroundElement(content, style);
                      case "gradient-panel":
                          return new GradientPanelElement(content, style);
                      case "progress-ring":
                          return new ProgressRingElement(content, style);
                      case "tech-stack":
                          return new TechStackElement(content, style);
                      default:
                          console.warn(`未知元素类型: ${type}，回退到文本元素`);
                          return new TextElement(content, style);
                  }
              }

              static getRegisteredTypes() {
                  const baseTypes = ["text", "image", "chart", "list", "background",
                                    "gradient-panel", "progress-ring", "tech-stack"];
                  const customTypes = Array.from(this.customElements.keys());
                  return [...baseTypes, ...customTypes];
              }
          }

          // ==================== 注册自定义元素类型 ====================
          ElementRegistry.registerElementType("gradient-panel", GradientPanelElement);
          ElementRegistry.registerElementType("progress-ring", ProgressRingElement);
          ElementRegistry.registerElementType("tech-stack", TechStackElement);

          // ==================== 幻灯片类 ====================
          class Slide {
              constructor(title = "新幻灯片", elements = []) {
                  this.title = title;
                  this.elements = elements;
                  this.id = "slide_" + Date.now() + Math.floor(Math.random() * 1000);
                  this.backgroundColor = "#ffffff";
                  this.backgroundImage = "";
              }

              addElement(element) {
                  this.elements.push(element);
              }

              removeElement(elementId) {
                  this.elements = this.elements.filter((el) => el.id !== elementId);
              }

              render() {
                  const elementsHTML = this.elements
                      .map((element) => element.render())
                      .join("");

                  return `
                      <div class="slide" id="${this.id}" style="background: ${this.backgroundColor}">
                          <div class="slide-body">
                              ${elementsHTML}
                          </div>
                      </div>
                  `;
              }

              renderElements() {
                  this.elements.forEach((element) => {
                      if (element.type === 'chart') {
                          // 延迟调用以确保DOM已渲染
                          setTimeout(() => {
                              try {
                                  element.renderChart();
                              } catch (error) {
                                  console.error(`渲染图表元素${element.id}时出错:`, error);
                              }
                          }, 100);
                      }
                  });
              }
          }

          // ==================== 编辑管理器 ====================
          class EditManager {
              constructor() {
                  this.isEditMode = false;
                  this.selectedElement = null;
                  this.elements = new Map();
              }

              registerElement(element) {
                  this.elements.set(element.id, element);
                  if (this.isEditMode && element.enableEdit) {
                      setTimeout(() => {
                          try {
                              element.enableEdit();
                          } catch (error) {
                              console.error("启用元素编辑时出错:", error);
                          }
                      }, 0);
                  }
              }

              unregisterElement(elementId) {
                  const element = this.elements.get(elementId);
                  if (element) {
                      element.disableEdit();
                      this.elements.delete(elementId);
                  }
              }

              enableGlobalEdit() {
                  this.isEditMode = true;
                  this.elements.forEach((element) => {
                      if (element.enableEdit) {
                          try {
                              element.enableEdit();
                          } catch (error) {
                              console.error("启用元素编辑时出错:", error);
                          }
                      }
                  });
              }

              disableGlobalEdit() {
                  this.isEditMode = false;
                  this.elements.forEach((element) => {
                      if (element.disableEdit) {
                          try {
                              element.disableEdit();
                          } catch (error) {
                              console.error("禁用元素编辑时出错:", error);
                          }
                      }
                  });
                  this.selectedElement = null;
              }

              selectElement(elementId) {
                  if (this.selectedElement) {
                      const prevElement = this.elements.get(this.selectedElement);
                      if (prevElement) {
                          prevElement.disableEdit();
                          prevElement.enableEdit();
                      }
                  }

                  this.selectedElement = elementId;
                  const element = this.elements.get(elementId);
                  if (element) {
                      element.enableEdit();
                  }
              }

              getSnapshot() {
                  const snapshot = [];
                  this.elements.forEach((element) => {
                      snapshot.push(element.getState());
                  });
                  return snapshot;
              }

              restoreSnapshot(snapshot) {
                  this.elements.clear();
                  snapshot.forEach((elementState) => {
                      const element = ElementRegistry.createElement(
                          elementState.type,
                          elementState.content,
                          elementState.style
                      );

                      if (element) {
                          element.setState(elementState);
                          this.registerElement(element);
                      }
                  });
              }

              cleanup() {
                  this.elements.forEach((element) => {
                      element.removeEditControls();
                  });
                  this.elements.clear();
              }
          }

          // ==================== PPT管理类 ====================
          class PPTManager {
              constructor() {
                  this.slides = [];
                  this.currentSlideIndex = 0;
                  this.isEditMode = false;
                  this.editManager = new EditManager();
                  this.history = [];
                  this.historyIndex = -1;
                  this.historyLimit = 30;
                  this.themes = {
                      default: {
                          primaryColor: "#3498db",
                          secondaryColor: "#2c3e50",
                          accentColor: "#e74c3c",
                          backgroundColor: "#ffffff",
                          textColor: "#2c3e50",
                      },
                      dark: {
                          primaryColor: "#3498db",
                          secondaryColor: "#ecf0f1",
                          accentColor: "#e74c3c",
                          backgroundColor: "#2c3e50",
                          textColor: "#ecf0f1",
                      },
                      nature: {
                          primaryColor: "#2ecc71",
                          secondaryColor: "#34495e",
                          accentColor: "#f39c12",
                          backgroundColor: "#f9f9f9",
                          textColor: "#2c3e50",
                      },
                  };
                  this.currentTheme = "default";
                  this.init();
              }
// 在PPTManager类中添加图表数据输入方法
        async showChartDataInput(chartType) {
            return new Promise((resolve) => {
                // 创建模态框
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;

                // 根据图表类型设置默认数据
                let defaultData = this.getDefaultChartData(chartType);
                
                modal.innerHTML = `
                    <div style="background: white; padding: 20px; border-radius: 8px; width: 600px; max-width: 90vw; max-height: 80vh; overflow-y: auto;">
                        <h3 style="margin-bottom: 20px;">设置图表数据 - ${this.getChartTypeName(chartType)}</h3>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">图表标题:</label>
                            <input type="text" id="chart-title" value="${defaultData.title}" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        </div>

                        ${chartType !== 'pie' ? `
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">X轴数据 (用逗号分隔):</label>
                            <input type="text" id="chart-xdata" value="${defaultData.xAxis?.data?.join(',') || ''}"
                                placeholder="例如: 1月,2月,3月,4月" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        </div>

                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">Y轴数据 (用逗号分隔):</label>
                            <input type="text" id="chart-ydata" value="${defaultData.series[0]?.data?.map(item => item.value || item).join(',') || ''}"
                                placeholder="例如: 10,20,15,25" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        </div>
                        ` : ''}

                        ${chartType === 'pie' ? `
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">饼图数据 (格式: 名称:数值, 用逗号分隔):</label>
                            <input type="text" id="chart-piedata" value="${defaultData.series[0].data.map(item => `${item.name}:${item.value}`).join(',')}" 
                                placeholder="例如: 产品A:35,产品B:25,产品C:20" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        </div>
                        ` : ''}

                        <div style="display: flex; gap: 10px; margin-top: 20px;">
                            <button id="confirm-chart" style="padding: 10px 20px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1;">
                                确认
                            </button>
                            <button id="cancel-chart" style="padding: 10px 20px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer; flex: 1;">
                                取消
                            </button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);

                // 处理确认
                modal.querySelector('#confirm-chart').addEventListener('click', () => {
                    const title = modal.querySelector('#chart-title').value;
                    
                    let chartOption;
                    
                    if (chartType === 'pie') {
                        const pieDataInput = modal.querySelector('#chart-piedata').value;
                        const pieData = pieDataInput.split(',').map(item => {
                            const [name, value] = item.split(':').map(part => part.trim());
                            return { name, value: parseFloat(value) || 0 };
                        });
                        
                        chartOption = {
                            title: { text: title || '饼图' },
                            tooltip: { trigger: 'item' },
                            series: [{
                                name: '数据',
                                type: 'pie',
                                radius: '50%',
                                data: pieData
                            }]
                        };
                    } else {
                        const xData = modal.querySelector('#chart-xdata').value.split(',').map(item => item.trim());
                        const yData = modal.querySelector('#chart-ydata').value.split(',').map(item => parseFloat(item.trim()) || 0);
                        chartOption = {
                            title: { text: title || this.getChartTypeName(chartType) },
                            tooltip: {},
                            xAxis: { 
                                type: chartType === 'scatter' ? 'value' : 'category',
                                data: chartType === 'scatter' ? null : xData
                            },
                            yAxis: {},
                            series: [{
                                name: '数据',
                                type: chartType,
                                data: chartType === 'scatter' ? this.parseScatterData(xData, yData) : yData
                            }]
                        };
                    }

                    document.body.removeChild(modal);
                    resolve(chartOption);
                });

                // 处理取消
                modal.querySelector('#cancel-chart').addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve(null);
                });
            });
        }

        // 辅助方法：获取图表类型名称
        getChartTypeName(chartType) {
            const names = {
                'bar': '柱状图',
                'line': '折线图', 
                'pie': '饼图',
                'scatter': '散点图'
            };
            return names[chartType] || '图表';
        }

        // 辅助方法：获取默认图表数据
        getDefaultChartData(chartType) {
            const defaults = {
                'bar': {
                    title: '柱状图',
                    xAxis: { data: ['1月', '2月', '3月', '4月', '5月'] },
                    series: [{ data: [10, 20, 15, 25, 18] }]
                },
                'line': {
                    title: '折线图', 
                    xAxis: { data: ['1月', '2月', '3月', '4月', '5月'] },
                    series: [{ data: [15, 23, 18, 35, 28] }]
                },
                'pie': {
                    title: '饼图',
                    series: [{
                        data: [
                            { value: 35, name: '产品A' },
                            { value: 25, name: '产品B' },
                            { value: 20, name: '产品C' },
                            { value: 15, name: '产品D' },
                            { value: 5, name: '产品E' }
                        ]
                    }]
                },
                'scatter': {
                    title: '散点图',
                    xAxis: { data: [] },
                    series: [{ data: [[10, 8], [15, 12], [20, 18], [25, 22], [30, 28]] }]
                }
            };
            return defaults[chartType] || defaults.bar;
        }

        // 辅助方法：解析散点图数据
        parseScatterData(xData, yData) {
            const scatterData = [];
            const length = Math.min(xData.length, yData.length);
            for (let i = 0; i < length; i++) {
                scatterData.push([parseFloat(xData[i]) || 0, parseFloat(yData[i]) || 0]);
            }
            return scatterData;
        }
      // 在PPTManager类中添加新方法
      showChartTypeDialog() {
          return new Promise((resolve) => {
              // 创建模态框
              const modal = document.createElement('div');
              modal.style.cssText = `
                  position: fixed;
                  top: 0;
                  left: 0;
                  width: 100%;
                  height: 100%;
                  background: rgba(0,0,0,0.5);
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  z-index: 10000;
              `;

              modal.innerHTML = `
                  <div style="background: white; padding: 20px; border-radius: 8px; width: 400px; max-width: 90vw;">
                      <h3 style="margin-bottom: 20px;">选择图表类型</h3>
                      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px;">
                          <button data-type="bar" style="padding: 10px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                              柱状图
                          </button>
                          <button data-type="line" style="padding: 10px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                              折线图
                          </button>
                          <button data-type="pie" style="padding: 10px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                              饼图
                          </button>
                          <button data-type="scatter" style="padding: 10px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                              散点图
                          </button>
                      </div>
                      <button id="cancel-chart" style="padding: 8px 16px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer;">
                          取消
                      </button>
                  </div>
              `;

              document.body.appendChild(modal);

              // 处理图表类型选择
              modal.querySelectorAll('button[data-type]').forEach(btn => {
                  btn.addEventListener('click', () => {
                      const type = btn.getAttribute('data-type');
                      document.body.removeChild(modal);
                      resolve(type);
                  });
              });

              // 处理取消
              modal.querySelector('#cancel-chart').addEventListener('click', () => {
                  document.body.removeChild(modal);
                  resolve(null);
              });
          });
      }
              saveToLocalStorage() {
                  try {
                      const presentationData = {
                          slides: this.slides.map((slide) => {
                              return {
                                  title: slide.title,
                                  backgroundColor: slide.backgroundColor,
                                  backgroundImage: slide.backgroundImage,
                                  elements: slide.elements.map((element) => element.getState()),
                              };
                          }),
                          currentSlideIndex: this.currentSlideIndex,
                      };

                      localStorage.setItem("ai-ppt-presentation", JSON.stringify(presentationData));
                      return true;
                  } catch (error) {
                      console.error("保存到本地存储失败:", error);
                      return false;
                  }
              }

              loadFromLocalStorage() {
                  try {
                      const savedData = localStorage.getItem("ai-ppt-presentation");
                      if (savedData) {
                          const presentationData = JSON.parse(savedData);

                          this.slides = [];

                          presentationData.slides.forEach((slideData) => {
                              const slide = new Slide(slideData.title);
                              slide.backgroundColor = slideData.backgroundColor;
                              slide.backgroundImage = slideData.backgroundImage;

                              slideData.elements.forEach((elementState) => {
                                  const element = ElementRegistry.createElement(
                                      elementState.type,
                                      elementState.content,
                                      elementState.style
                                  );

                                  if (element) {
                                      element.setState(elementState);
                                      slide.addElement(element);
                                  }
                              });

                              this.slides.push(slide);
                          });

                          this.currentSlideIndex = presentationData.currentSlideIndex;
                          this.renderSlides();
                          this.renderSlideList();

                          return true;
                      }
                  } catch (error) {
                      console.error("从本地存储加载失败:", error);
                  }
                  return false;
              }

              createSnapshot() {
                  this.history = this.history.slice(0, this.historyIndex + 1);

                  const snapshot = {
                      slides: this.slides.map((slide) => {
                          return {
                              title: slide.title,
                              backgroundColor: slide.backgroundColor,
                              backgroundImage: slide.backgroundImage,
                              elements: slide.elements.map((element) => element.getState()),
                          };
                      }),
                      currentSlideIndex: this.currentSlideIndex,
                  };

                  this.history.push(snapshot);
                  this.historyIndex++;

                  if (this.history.length > this.historyLimit) {
                      this.history.shift();
                      this.historyIndex--;
                  }
              }

              undo() {
                  if (this.historyIndex > 0) {
                      this.historyIndex--;
                      this.restoreFromSnapshot(this.history[this.historyIndex]);
                  }
              }

              redo() {
                  if (this.historyIndex < this.history.length - 1) {
                      this.historyIndex++;
                      this.restoreFromSnapshot(this.history[this.historyIndex]);
                  }
              }

              restoreFromSnapshot(snapshot) {
                  this.slides = [];

                  snapshot.slides.forEach((slideData) => {
                      const slide = new Slide(slideData.title);
                      slide.backgroundColor = slideData.backgroundColor;
                      slide.backgroundImage = slideData.backgroundImage;

                      slideData.elements.forEach((elementState) => {
                          const element = ElementRegistry.createElement(
                              elementState.type,
                              elementState.content,
                              elementState.style
                          );

                          if (element) {
                              element.setState(elementState);
                              slide.addElement(element);
                          }
                      });

                      this.slides.push(slide);
                  });

                  this.currentSlideIndex = snapshot.currentSlideIndex;
                  this.renderSlides();
                  this.renderSlideList();
              }

              applyTheme(themeName) {
                  if (!this.themes[themeName]) return;

                  this.currentTheme = themeName;
                  const theme = this.themes[themeName];

                  document.documentElement.style.setProperty("--primary-color", theme.primaryColor);
                  document.documentElement.style.setProperty("--secondary-color", theme.secondaryColor);
                  document.documentElement.style.setProperty("--accent-color", theme.accentColor);
                  document.documentElement.style.setProperty("--background-color", theme.backgroundColor);
                  document.documentElement.style.setProperty("--text-color", theme.textColor);

                  this.slides.forEach((slide) => {
                      slide.backgroundColor = theme.backgroundColor;
                  });

                  this.renderSlides();
              }

              init() {
                  if (!this.loadFromLocalStorage()) {
                      this.addSlide("欢迎使用AI PPT");
                      const firstSlide = this.slides[0];

                      firstSlide.addElement(
                          new TextElement({
                              title: "AI PPT生成系统",
                              body: "这是一个基于HTML、CSS和JavaScript的智能PPT生成系统，支持动态内容生成和编辑。",
                          })
                      );

                      firstSlide.addElement(
                          new ListElement({
                              title: "主要功能",
                              items: [
                                  "智能内容生成",
                                  "动态图表插入",
                                  "多模式切换",
                                  "导出为PPT文件",
                              ],
                          })
                      );
                  }

                  this.addJSONImportFeature();
                  this.renderSlides();
                  this.renderSlideList();
                  this.bindEvents();

                  setInterval(() => {
                      this.saveToLocalStorage();
                  }, 30000);
              }

              addSlide(title = "新幻灯片") {
                  this.createSnapshot();
                  const newSlide = new Slide(title);
                  this.slides.push(newSlide);
                  this.currentSlideIndex = this.slides.length - 1;
                  this.renderSlides();
                  this.renderSlideList();
                  return newSlide;
              }

              removeSlide(index) {
                  this.createSnapshot();
                  if (this.slides.length <= 1) {
                      alert("至少需要保留一张幻灯片");
                      return;
                  }

                  this.slides.splice(index, 1);

                  if (this.currentSlideIndex >= index) {
                      this.currentSlideIndex = Math.max(0, this.currentSlideIndex - 1);
                  }

                  this.renderSlides();
                  this.renderSlideList();
              }

              nextSlide() {
                  if (this.currentSlideIndex < this.slides.length - 1) {
                      this.currentSlideIndex++;
                      this.renderSlides();
                      this.renderSlideList();
                  }
              }

              prevSlide() {
                  if (this.currentSlideIndex > 0) {
                      this.currentSlideIndex--;
                      this.renderSlides();
                      this.renderSlideList();
                  }
              }

              goToSlide(index) {
                  if (index >= 0 && index < this.slides.length) {
                      this.currentSlideIndex = index;
                      this.renderSlides();
                      this.renderSlideList();
                  }
              }

 renderSlides() {
    const presentationArea = document.getElementById("presentation-area");

    if (!presentationArea) {
        console.error("演示区域元素未找到");
        return;
    }

    presentationArea.innerHTML = "";

    const currentSlide = this.slides[this.currentSlideIndex];
    if (currentSlide) {
        const slideElement = document.createElement("div");
        slideElement.innerHTML = currentSlide.render();
        const slideDOM = slideElement.firstElementChild;

        slideDOM.classList.add("active");
        
        // 设置幻灯片初始位置和尺寸
        slideDOM.style.position = 'absolute';
        slideDOM.style.left = '50%';
        slideDOM.style.top = '50%';
        slideDOM.style.marginLeft = `-512px`; // 1024/2
        slideDOM.style.marginTop = `-288px`; // 576/2
        slideDOM.style.width = '1024px';
        slideDOM.style.height = '576px';

        presentationArea.appendChild(slideDOM);

        currentSlide.elements.forEach((element) => {
            try {
                this.editManager.registerElement(element);
            } catch (error) {
                console.error(`注册元素${element.id}时出错:`, error);
            }
        });

        setTimeout(() => {
            try {
                currentSlide.renderElements();
                
                // 如果是全屏模式，调整尺寸
                if (document.fullscreenElement) {
                    this.zoomToFitFullscreen();
                }
            } catch (error) {
                console.error("渲染图表元素时出错:", error);
            }
        }, 100);
    }
}
              renderSlideList() {
    const slideList = document.getElementById("slide-list");
    if (!slideList) return;

    // 清空列表
    slideList.innerHTML = "";

    this.slides.forEach((slide, index) => {
        const slideItem = document.createElement("div");
        slideItem.className = `slide-item ${index === this.currentSlideIndex ? "active" : ""}`;
        slideItem.draggable = true;
        slideItem.setAttribute("data-index", index);
        slideItem.innerHTML = `
            ${index + 1}. ${slide.title}
            <div class="slide-actions">
                <div class="slide-action edit-slide" title="编辑标题">✏️</div>
                <div class="slide-action delete-slide" title="删除幻灯片">🗑️</div>
            </div>
        `;

        slideItem.addEventListener("click", () => {
            this.goToSlide(index);
        });

        const editBtn = slideItem.querySelector(".edit-slide");
        editBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            const newTitle = prompt("请输入新标题:", slide.title);
            if (newTitle) {
                slide.title = newTitle;
                this.renderSlideList();
            }
        });

        const deleteBtn = slideItem.querySelector(".delete-slide");
        deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            this.removeSlide(index);
        });

        // 拖拽开始事件 - 使用dataTransfer传递索引
        slideItem.addEventListener("dragstart", (e) => {
            e.dataTransfer.effectAllowed = 'move';
            // 使用dataTransfer传递拖拽索引，而不是局部变量
            e.dataTransfer.setData('text/plain', index.toString());
            slideItem.classList.add("dragging");
            // 设置半透明效果以提供视觉反馈
            slideItem.style.opacity = "0.5";
        });

        // 拖拽结束事件 - 清理拖拽状态
        slideItem.addEventListener("dragend", () => {
            slideItem.classList.remove("dragging");
            slideItem.style.opacity = "1";
            // 移除所有放置指示器
            document.querySelectorAll(".slide-item.placeholder").forEach(el => el.remove());
        });

        // 拖拽经过事件 - 允许放置并显示放置位置
        slideItem.addEventListener("dragover", (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            // 移除所有已存在的放置指示器
            document.querySelectorAll(".slide-item.placeholder").forEach(el => el.remove());
            
            // 获取拖拽索引
            const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
            
            // 计算鼠标位置，决定是放在上方还是下方
            const rect = slideItem.getBoundingClientRect();
            const mouseY = e.clientY - rect.top;
            const slideHeight = rect.height;
            
            // 避免在同一个元素上放置并检查拖拽索引有效性
            if (draggedIndex !== index && !isNaN(draggedIndex)) {
                // 创建放置指示器
                const placeholder = document.createElement("div");
                placeholder.className = "slide-item placeholder";
                placeholder.style.backgroundColor = "rgba(52, 152, 219, 0.3)";
                placeholder.style.height = "40px";
                placeholder.style.marginBottom = "8px";
                placeholder.style.borderRadius = "5px";
                placeholder.style.border = "2px dashed #3498db";
                 
                if (mouseY < slideHeight / 2) {
                    // 放在当前幻灯片上方
                    slideList.insertBefore(placeholder, slideItem);
                } else {
                    // 放在当前幻灯片下方
                    slideList.insertBefore(placeholder, slideItem.nextSibling);
                }
            }
        });

        // 放置事件 - 执行幻灯片移动
        slideItem.addEventListener("drop", (e) => {
            e.preventDefault();
            
            // 获取拖拽索引
            const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
            
            // 确保有拖拽的幻灯片
            if (isNaN(draggedIndex)) return;
            
            // 计算最终目标位置
            const rect = slideItem.getBoundingClientRect();
            const mouseY = e.clientY - rect.top;
            const slideHeight = rect.height;
            let finalToIndex = index;
            
            if (mouseY < slideHeight / 2) {
                // 放在当前幻灯片上方
                finalToIndex = index;
            } else {
                // 放在当前幻灯片下方
                finalToIndex = index + 1;
            }
            
            // 如果拖拽到了列表末尾
            if (finalToIndex > this.slides.length - 1) {
                finalToIndex = this.slides.length;
            }
            
            // 避免无效的移动
            if (draggedIndex !== finalToIndex && draggedIndex >= 0 && finalToIndex >= 0 && finalToIndex <= this.slides.length) {
                console.log('执行移动:', draggedIndex, '->', finalToIndex);
                // 直接调用moveSlide方法处理移动
                this.moveSlide(draggedIndex, finalToIndex);
            }
            
            // 移除放置指示器
            document.querySelectorAll(".slide-item.placeholder").forEach(el => el.remove());
        });

        slideList.appendChild(slideItem);
    });
}

              // 移动幻灯片位置的方法
              moveSlide(fromIndex, toIndex) {
                  console.log('移动幻灯片前:', fromIndex, '->', toIndex);
                  console.log('移动前slides数组:', this.slides.map(s => s.title));
                  
                  this.createSnapshot(); // 创建快照以便撤销
                  
                  // 调整目标位置，因为从原位置移除后，数组长度会减1
                  if (fromIndex < toIndex) {
                      toIndex--;
                      console.log('调整后toIndex:', toIndex);
                  }
                  
                  // 从原位置移除并插入到新位置
                  const [movedSlide] = this.slides.splice(fromIndex, 1);
                  this.slides.splice(toIndex, 0, movedSlide);
                  
                  console.log('移动后slides数组:', this.slides.map(s => s.title));
                  
                  // 更新当前幻灯片索引
                  if (this.currentSlideIndex === fromIndex) {
                      this.currentSlideIndex = toIndex;
                  } else if (this.currentSlideIndex > fromIndex && this.currentSlideIndex <= toIndex) {
                      this.currentSlideIndex--;
                  } else if (this.currentSlideIndex < fromIndex && this.currentSlideIndex >= toIndex) {
                      this.currentSlideIndex++;
                  }
                  
                  console.log('更新后currentSlideIndex:', this.currentSlideIndex);
                  
                  // 重新渲染
                  this.renderSlides();
                  this.renderSlideList();
                  
                  // 保存到本地存储
                  this.saveToLocalStorage();
                  console.log('已保存到本地存储');
              }

              toggleEditMode() {
                  if (this.isEditMode) {
                      this.saveToLocalStorage();
                  }

                  this.isEditMode = !this.isEditMode;

                  const toolbar = document.getElementById("toolbar");
                  const editModeBtn = document.getElementById("edit-mode");
                  const presentModeBtn = document.getElementById("present-mode");

                  if (this.isEditMode) {
                      if (editModeBtn) editModeBtn.classList.add("active");
                      if (presentModeBtn) presentModeBtn.classList.remove("active");
                      if (toolbar) toolbar.style.display = "flex";
                      this.enableEditMode();

                  } else {
                      if (presentModeBtn) presentModeBtn.classList.add("active");
                      if (editModeBtn) editModeBtn.classList.remove("active");
                      if (toolbar) toolbar.style.display = "none";
                      this.disableEditMode();

                  }
              }

              enableEditMode() {
                  try {
                      this.editManager.enableGlobalEdit();
                  } catch (error) {
                      console.error("启用编辑模式时出错:", error);
                      showNotification("切换编辑模式时发生错误", "error");
                  }
              }

              disableEditMode() {
                  try {
                      this.editManager.disableGlobalEdit();
                  } catch (error) {
                      console.error("禁用编辑模式时出错:", error);
                      showNotification("切换放映模式时发生错误", "error");
                  }
              }

              async addElement(type) {
                  this.createSnapshot();
                  const currentSlide = this.slides[this.currentSlideIndex];
                  let newElement;

                  switch (type) {
                      case "text":
                          newElement = new TextElement({
                              title: "新文本标题",
                              body: "这里是文本内容...",
                          });
                          newElement.size = { width: 300, height: 150 };
                          newElement.position = { x: 100, y: 100 };
                          break;
                      case "image":
                          // 创建文件输入元素
                          const fileInput = document.createElement('input');
                          fileInput.type = 'file';
                          fileInput.accept = 'image/*';

                          // 文件选择事件
                          fileInput.addEventListener('change', (event) => {
                              const file = event.target.files[0];
                              if (file) {
                                  const reader = new FileReader();

                                  reader.onload = (e) => {
                                      newElement = new ImageElement({
                                          src: e.target.result,
                                          alt: file.name || '用户上传图片',
                                      });
                                      newElement.size = { width: 300, height: 200 };
                                      newElement.position = { x: 100, y: 100 };

                                      currentSlide.addElement(newElement);
                                      this.renderSlides();
                                      showNotification('图片已添加', 'success');
                                  };

                                  reader.readAsDataURL(file);
                              } else {
                                  // 如果用户取消选择，仍然添加占位符图片作为后备方案
                                  newElement = new ImageElement({
                                      src: "https://via.placeholder.com/400x300",
                                      alt: "示例图片",
                                  });
                                  newElement.size = { width: 300, height: 200 };
                                  newElement.position = { x: 100, y: 100 };

                                  currentSlide.addElement(newElement);
                                  this.renderSlides();
                              }
                          });

                          // 触发文件选择对话框
                          fileInput.click();
                          return; // 提前返回，等待文件选择完成
                        case "chart":
                            const chartType = await this.showChartTypeDialog();
                            if (!chartType) return; // 用户取消了选择
                            
                            // 显示数据输入弹窗
                            const chartOption = await this.showChartDataInput(chartType);
                            if (!chartOption) return; // 用户取消了数据输入
                            
                            newElement = new ChartElement({ chartOption });
                            newElement.size = { width: 500, height: 300 };
                            newElement.position = { x: 50, y: 100 };
                            break;
                        case "list":
                          newElement = new ListElement({
                              title: "新列表",
                              items: ["项目1", "项目2", "项目3"],
                          });
                          newElement.size = { width: 300, height: 200 };
                          newElement.position = { x: 100, y: 100 };
                          break;
                      case "gradient-panel":
                          newElement = new GradientPanelElement({
                              color1: "#2A5CFF",
                              color2: "#638DFF",
                              title: "渐变面板标题",
                              content: "这里是渐变面板的内容...",
                              textColor: "#FFFFFF"
                          });
                          newElement.size = { width: 300, height: 200 };
                          newElement.position = { x: 100, y: 100 };
                          break;
                      case "progress-ring":
                          newElement = new ProgressRingElement({
                              value: 75,
                              size: 100,
                              progressColor: "#3B82F6",
                              trackColor: "#E5E7EB",
                              textColor: "#1F2937"
                          });
                          newElement.size = { width: 200, height: 150 };
                          newElement.position = { x: 100, y: 100 };
                          break;
                      case "tech-stack":
                          newElement = new TechStackElement({
                              color1: "rgba(79, 172, 254, 0.3)",
                              color2: "rgba(0, 242, 254, 0.3)",
                              title: "技术栈",
                              content: "React + TypeScript + Node.js",
                              textColor: "#ffffff"
                          });
                          newElement.size = { width: 300, height: 200 };
                          newElement.position = { x: 100, y: 100 };
                          break;
                  }

                  if (newElement) {
                      currentSlide.addElement(newElement);
                      this.renderSlides();
                  }
              }

              // 保存为PPT或PDF功能
              async savePresentation() {
                  try {
                      // 显示导出选项对话框
                      const exportType = await this.showExportOptionsDialog();
                      if (!exportType) return; // 用户取消

                      if (exportType === 'pdf') {
                          // PDF导出
                          await this.exportToPDF();
                      } else if (exportType === 'editable-pptx') {
                          // 可编辑PPTX导出
                          await this.exportToEditablePPTX();
                      } else if (exportType === 'pptx') {
                          // PPT导出（截图版）
                          await this.saveAsPPT();
                      }
                  } catch (error) {
                      console.error("导出失败:", error);
                      alert("导出失败，请重试或检查控制台错误信息。");
                  }
              }

              // 显示导出选项对话框
              showExportOptionsDialog() {
                  return new Promise((resolve) => {
                      // 创建模态框
                      const modal = document.createElement('div');
                      modal.style.cssText = `
                          position: fixed;
                          top: 0;
                          left: 0;
                          width: 100%;
                          height: 100%;
                          background: rgba(0,0,0,0.5);
                          display: flex;
                          align-items: center;
                          justify-content: center;
                          z-index: 10000;
                      `;

                      modal.innerHTML = `
                          <div style="background: white; padding: 20px; border-radius: 8px; width: 400px; max-width: 90vw;">
                              <h3 style="margin-bottom: 20px;">选择导出格式</h3>
                              <div style="display: flex; flex-direction: column; gap: 10px; margin-bottom: 20px;">
                                  <button data-type="editable-pptx" style="padding: 15px; border: 2px solid #3498db; border-radius: 4px; cursor: pointer; background-color: #e8f4fc; font-weight: bold;">
                                      ✨ 导出为可编辑PPTX（推荐）
                                  </button>
                                  <button data-type="pptx" style="padding: 15px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; background-color: #f8f9fa;">
                                      保存为PPT（截图版）
                                  </button>
                                  <button data-type="pdf" style="padding: 15px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; background-color: #f8f9fa;">
                                      保存为PDF
                                  </button>
                              </div>
                              <button id="cancel-export" style="padding: 8px 16px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%;">
                                  取消
                              </button>
                          </div>
                      `;

                      document.body.appendChild(modal);

                      // 处理导出类型选择
                      modal.querySelectorAll('button[data-type]').forEach(btn => {
                          btn.addEventListener('click', () => {
                              const type = btn.getAttribute('data-type');
                              document.body.removeChild(modal);
                              resolve(type);
                          });
                      });

                      // 处理取消
                      modal.querySelector('#cancel-export').addEventListener('click', () => {
                          document.body.removeChild(modal);
                          resolve(null);
                      });
                    });
                }

              // 导出为PDF
              async exportToPDF() {
                  try {
                      // 确保html2canvas和jsPDF库都已加载
                      if (typeof html2canvas === "undefined" || typeof jspdf === "undefined") {
                          alert("正在加载必要的库，请稍后再试...");
                          
                          // 先加载html2canvas
                          if (typeof html2canvas === "undefined") {
                              await new Promise((resolve) => {
                                  const script = document.createElement("script");
                                  script.src = "https://html2canvas.hertzen.com/dist/html2canvas.min.js";
                                  script.onload = resolve;
                                  document.head.appendChild(script);
                              });
                          }
                          
                          // 再加载jsPDF
                          if (typeof jspdf === "undefined") {
                              await new Promise((resolve) => {
                                  const script = document.createElement("script");
                                  script.src = "https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js";
                                  script.onload = resolve;
                                  document.head.appendChild(script);
                              });
                          }
                          
                          // 等待一小段时间确保库完全初始化
                          await new Promise(resolve => setTimeout(resolve, 300));
                      }
                      
                      // 使用不同的方式获取jsPDF实例
                      let pdf;
                      if (window.jspdf && window.jspdf.jsPDF) {
                          // UMD模块方式
                          pdf = new window.jspdf.jsPDF('l', 'mm', 'a4'); // 横向A4
                      } else if (window.jsPDF) {
                          // 全局变量方式
                          pdf = new window.jsPDF('l', 'mm', 'a4'); // 横向A4
                      } else {
                          alert("jsPDF库加载失败，请刷新页面重试。");
                          console.error("无法找到jsPDF实例");
                          return;
                      }
                      
                      const currentSlideIndex = this.currentSlideIndex;

                      for (let i = 0; i < this.slides.length; i++) {
                          this.goToSlide(i);
                          await new Promise((resolve) => setTimeout(resolve, 300));

                          const slideElement = document.querySelector('.slide.active');
                          if (!slideElement) continue;

                          const canvas = await html2canvas(slideElement, {
                              scale: 2,
                              logging: false,
                              useCORS: true,
                          });

                          const imgData = canvas.toDataURL("image/png");

                          // 计算图片在PDF中的位置和大小（A4横向尺寸为297mm x 210mm）
                          const pageWidth = pdf.internal.pageSize.getWidth();
                          const pageHeight = pdf.internal.pageSize.getHeight();
                          const imgWidth = pageWidth - 20; // 左右各留10mm边距
                          const imgHeight = (canvas.height * imgWidth) / canvas.width;
                          const imgX = 10;
                          const imgY = (pageHeight - imgHeight) / 2;

                          if (i > 0) {
                              pdf.addPage();
                          }

                          pdf.addImage(imgData, 'PNG', imgX, imgY, imgWidth, imgHeight);
                      }

                      this.goToSlide(currentSlideIndex);
                      pdf.save(`AI_PPT_演示文稿_${new Date().toLocaleDateString().replace(/\//g, '-')}.pdf`);
                      showNotification('PDF导出成功！', 'success');
                  } catch (error) {
                      console.error("导出PDF失败:", error);
                      alert("导出PDF失败，请重试或检查控制台错误信息。");
                  }
              }

              // 保存为PPT
              async saveAsPPT() {
                  try {
                      console.log("开始PPT导出流程");
                      
                      // 获取当前时间戳用于调试
                      const startTime = Date.now();
                      
                      // 确保所有幻灯片已经渲染
                      await new Promise(resolve => setTimeout(resolve, 200));
                      
                      // 检查必要的库是否已加载
                      if (typeof html2canvas === "undefined" || typeof PptxGenJS === "undefined") {
                          console.log("检测到必要的库未加载，开始加载");
                          
                          // 显示加载中提示
                          const loadingAlert = document.createElement('div');
                          loadingAlert.id = "ppt-loading-alert";
                          loadingAlert.style.cssText = `
                              position: fixed;
                              top: 50%;
                              left: 50%;
                              transform: translate(-50%, -50%);
                              background: white;
                              padding: 20px 40px;
                              border-radius: 8px;
                              box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                              z-index: 10000;
                              font-size: 16px;
                              text-align: center;
                          `;
                          loadingAlert.textContent = "正在加载必要的库，请稍候...";
                          document.body.appendChild(loadingAlert);

                          try {
                              // 顺序加载库，先加载html2canvas，再加载PptxGenJS
                              // 先尝试加载html2canvas
                              if (typeof html2canvas === "undefined") {
                                  console.log("开始加载html2canvas库");
                                  await new Promise((resolve, reject) => {
                                      const script = document.createElement("script");
                                      script.src = "https://html2canvas.hertzen.com/dist/html2canvas.min.js";
                                      script.onload = () => {
                                          console.log("html2canvas库加载完成，耗时:", Date.now() - startTime, "ms");
                                          resolve();
                                      };
                                      script.onerror = (err) => {
                                          console.error("html2canvas库加载失败:", err);
                                          reject(new Error("html2canvas库加载失败"));
                                      };
                                      document.head.appendChild(script);
                                  });
                              }
                              
                              // 再尝试加载PptxGenJS
                              if (typeof PptxGenJS === "undefined") {
                                  console.log("开始加载PptxGenJS库");
                                  // 尝试使用更可靠的CDN源
                                  try {
                                      await new Promise((resolve, reject) => {
                                          const script = document.createElement("script");
                                          // 使用jsdelivr CDN替代unpkg
                                          script.src = "https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgenjs.bundle.js";
                                          script.onload = () => {
                                              console.log("PptxGenJS库加载完成(jsdelivr)，耗时:", Date.now() - startTime, "ms");
                                              resolve();
                                          };
                                          script.onerror = (err) => {
                                              console.error("PptxGenJS库加载失败(jsdelivr):", err);
                                              reject(new Error("PptxGenJS库加载失败(jsdelivr)"));
                                          };
                                          document.head.appendChild(script);
                                      });
                                  } catch (e) {
                                      console.warn("主CDN加载失败，尝试备用CDN");
                                      // 尝试备用CDN源
                                          await new Promise((resolve, reject) => {
                                              const script = document.createElement("script");
                                              script.src = "https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgenjs.bundle.js";
                                          script.onload = () => {
                                              console.log("PptxGenJS库加载完成(备用CDN)，耗时:", Date.now() - startTime, "ms");
                                              resolve();
                                          };
                                          script.onerror = (err) => {
                                              console.error("PptxGenJS库加载失败(所有CDN):", err);
                                              reject(new Error("PPT导出所需的核心库加载失败，请检查网络连接"));
                                          };
                                          document.head.appendChild(script);
                                      });
                                  }
                              }

                              // 给库足够的初始化时间，增加到1000ms
                              console.log("等待库初始化完成");
                              await new Promise(resolve => setTimeout(resolve, 1000));
                                
                              // 检查库是否成功加载
                              console.log("检查库加载状态: html2canvas=", typeof html2canvas, "PptxGenJS=", typeof PptxGenJS);
                              if (typeof html2canvas === "undefined" || typeof PptxGenJS === "undefined") {
                                  // 作为备选方案，尝试直接使用window上的变量
                                  if (window.PptxGenJS) {
                                      console.log("找到window.PptxGenJS，尝试使用");
                                      PptxGenJS = window.PptxGenJS;
                                  } else if (window.pptxgenjs) {
                                      console.log("找到window.pptxgenjs，尝试使用");
                                      PptxGenJS = window.pptxgenjs;
                                  }
                                  
                                  if (window.html2canvas) {
                                      console.log("找到window.html2canvas，尝试使用");
                                      html2canvas = window.html2canvas;
                                  }
                                  
                                  // 再次检查
                                  if (typeof html2canvas === "undefined" || typeof PptxGenJS === "undefined") {
                                      console.error("库加载失败，无法继续导出");
                                      alert("必要的库加载失败，请刷新页面重试或检查网络连接。");
                                      return;
                                  }
                              }
                          } finally {
                              // 无论成功还是失败，都移除加载提示
                              if (loadingAlert.parentNode === document.body) {
                                  console.log("移除加载提示框");
                                  document.body.removeChild(loadingAlert);
                              }
                          }
                      }

                      console.log("库加载完成，开始创建PPT");
                      
                      // 尝试不同方式创建PptxGenJS实例
                      let pptx;
                      try {
                          pptx = new PptxGenJS();
                          console.log("成功创建PptxGenJS实例");
                      } catch (e) {
                          console.error("创建PptxGenJS实例失败:", e);
                          // 尝试其他可能的实例化方式
                          try {
                              console.log("尝试使用window.PptxGenJS创建实例");
                              pptx = new window.PptxGenJS();
                              console.log("成功使用window.PptxGenJS创建实例");
                          } catch (e2) {
                              console.error("所有尝试创建PptxGenJS实例的方式都失败了");
                              alert("PPT生成库初始化失败，请刷新页面重试。");
                              return;
                          }
                      }
                      
                      const currentSlideIndex = this.currentSlideIndex;

                      // 确保至少有一个幻灯片可导出
                      if (this.slides.length === 0) {
                          console.log("没有可导出的幻灯片");
                          alert("没有可导出的幻灯片，请先添加幻灯片。");
                          return;
                      }

                      console.log("开始处理幻灯片，共", this.slides.length, "张");
                      for (let i = 0; i < this.slides.length; i++) {
                          console.log("处理第", i + 1, "张幻灯片");
                          this.goToSlide(i);
                          await new Promise((resolve) => setTimeout(resolve, 300));

                          const slideElement = document.querySelector(`.slide:nth-child(${i + 1})`);
                          if (!slideElement) {
                              console.warn("未找到第", i + 1, "张幻灯片元素，跳过");
                              continue;
                          }

                          try {
                              const canvas = await html2canvas(slideElement, {
                                  scale: 2,
                                  logging: false,
                                  useCORS: true,
                              });
                              console.log("成功捕获幻灯片", i + 1, "的截图");

                              const imgData = canvas.toDataURL("image/png");
                              const pptSlide = pptx.addSlide();
                              console.log("成功添加PPT页面");

                              // 添加标题（如果有）
                              if (this.slides[i].title) {
                                  pptSlide.addText(this.slides[i].title, {
                                      x: 1,
                                      y: 1,
                                      w: "80%",
                                      h: 1,
                                      fontSize: 28,
                                      bold: true,
                                      color: "000000",
                                  });
                                  console.log("添加幻灯片标题");
                              }

                              // 添加幻灯片图片
                              pptSlide.addImage({
                                  data: imgData,
                                  x: 0.5,
                                  y: 1.5,
                                  w: 9,
                                  h: 6,
                              });
                              console.log("添加幻灯片图片");
                          } catch (e) {
                              console.error("处理幻灯片", i + 1, "时出错:", e);
                              // 继续处理下一张幻灯片，不中断整个流程
                          }
                      }

                      this.goToSlide(currentSlideIndex);
                      console.log("准备保存PPT文件");
                      
                      // 使用try-catch确保导出操作的稳定性
                      try {
                          // 尝试使用不同的保存方法
                          const fileName = `AI_PPT_演示文稿_${new Date().toLocaleDateString().replace(/\//g, '-')}.pptx`;
                          console.log("开始导出文件:", fileName);
                          
                          // 检查是否支持writeFile方法
                          if (typeof pptx.writeFile === 'function') {
                              pptx.writeFile({ fileName: fileName });
                          } else if (typeof pptx.save === 'function') {
                              // 备选方法
                              pptx.save(fileName);
                          } else {
                              throw new Error("未找到保存文件的方法");
                          }
                          
                          console.log("PPT导出成功，总耗时:", Date.now() - startTime, "ms");
                          showNotification('PPT导出成功！', 'success');
                      } catch (e) {
                          console.error("保存PPT文件失败:", e);
                          alert("PPT文件保存失败，请检查浏览器权限设置或尝试使用其他浏览器。");
                      }
                  } catch (error) {
                      console.error("导出PPT失败:", error);
                      alert("导出PPT失败，请重试或检查控制台错误信息。");
                  }
              }

              // 导出为可编辑PPTX
              async exportToEditablePPTX() {
                  try {
                      console.log("开始可编辑PPTX导出流程");
                      
                      // 检查PPTXExporter是否可用
                      if (!window.PPTXExporter) {
                          alert("PPTX导出模块未加载，请刷新页面重试。");
                          console.error("PPTXExporter未找到");
                          return;
                      }
                      
                      // 获取演示文稿数据
                      const presentationData = this.getPresentationData();
                      if (!presentationData || !presentationData.slides || presentationData.slides.length === 0) {
                          alert("没有可导出的幻灯片，请先添加幻灯片。");
                          return;
                      }
                      
                      console.log("准备导出", presentationData.slides.length, "张幻灯片");
                      
                      // 显示加载中提示
                      const loadingAlert = document.createElement('div');
                      loadingAlert.id = "editable-pptx-loading-alert";
                      loadingAlert.style.cssText = `
                          position: fixed;
                          top: 50%;
                          left: 50%;
                          transform: translate(-50%, -50%);
                          background: white;
                          padding: 30px 50px;
                          border-radius: 12px;
                          box-shadow: 0 8px 30px rgba(0,0,0,0.3);
                          z-index: 10000;
                          font-size: 16px;
                          text-align: center;
                          border: 2px solid #3498db;
                      `;
                      loadingAlert.innerHTML = `
                          <div style="margin-bottom: 15px; font-size: 24px;">⏳</div>
                          <div>正在生成可编辑PPTX...</div>
                          <div style="margin-top: 10px; font-size: 12px; color: #666;">
                              共 ${presentationData.slides.length} 张幻灯片
                          </div>
                      `;
                      document.body.appendChild(loadingAlert);
                      
                      try {
                          // 调用PPTXExporter生成PPTX
                          const result = await window.PPTXExporter.generate(presentationData);
                          
                          if (result.success) {
                              console.log("可编辑PPTX导出成功:", result.fileName);
                              showNotification(`可编辑PPTX导出成功！文件名: ${result.fileName}`, 'success');
                          } else {
                              console.error("可编辑PPTX导出失败:", result.error);
                              alert(`可编辑PPTX导出失败: ${result.error}`);
                          }
                      } finally {
                          // 移除加载提示
                          if (loadingAlert.parentNode === document.body) {
                              document.body.removeChild(loadingAlert);
                          }
                      }
                  } catch (error) {
                      console.error("导出可编辑PPTX失败:", error);
                      alert("导出可编辑PPTX失败，请重试或检查控制台错误信息。");
                  }
              }

              // 获取演示文稿数据
              getPresentationData() {
                  const slidesData = [];
                  
                  for (let i = 0; i < this.slides.length; i++) {
                      const slide = this.slides[i];
                      const slideData = {
                          title: slide.title || `幻灯片 ${i + 1}`,
                          backgroundColor: slide.backgroundColor || '#ffffff',
                          backgroundImage: slide.backgroundImage || '',
                          elements: []
                      };
                      
                      if (slide.elements && slide.elements.length > 0) {
                          slide.elements.forEach(element => {
                              if (element) {
                                  slideData.elements.push({
                                      type: element.type,
                                      content: element.content,
                                      style: element.style,
                                      position: { ...element.position },
                                      size: { ...element.size },
                                      rotation: element.rotation || 0,
                                      zIndex: element.zIndex || 0,
                                      id: element.id
                                  });
                              }
                          });
                      }
                      
                      slidesData.push(slideData);
                  }
                  
                  return {
                      slides: slidesData,
                      currentSlideIndex: this.currentSlideIndex,
                      version: '1.0',
                      exportDate: new Date().toISOString()
                  };
              }

              bindEvents() {
                  const navButtons = {
                      "prev-slide": this.prevSlide.bind(this),
                      "next-slide": this.nextSlide.bind(this),
                      "save-ppt": this.savePresentation.bind(this),
                      "fullscreen": this.toggleFullscreen.bind(this),
                      "add-slide": this.addSlide.bind(this),
                      "delete-slide": () => this.removeSlide(this.currentSlideIndex),
                      "present-mode": () => {
                          if (this.isEditMode) {
                              this.toggleEditMode();
                          }
                      },
                      "edit-mode": () => {
                          if (!this.isEditMode) {
                              this.toggleEditMode();
                          }
                      },
                      "export-json": this.exportToJSON.bind(this)
                  };

                  Object.entries(navButtons).forEach(([id, handler]) => {
                      const element = document.getElementById(id);
                      if (element) {
                          element.addEventListener("click", handler);
                      }
                  });

                  const toolbarButtons = {
                      "add-text": () => this.addElement("text"),
                      "add-image": () => this.addElement("image"),
                      "add-chart": () => this.addElement("chart"),
                      "add-list": () => this.addElement("list"),
                      "add-gradient-panel": () => this.addElement("gradient-panel"),
                      "add-progress-ring": () => this.addElement("progress-ring"),
                      "add-tech-stack": () => this.addElement("tech-stack"),
                  };

                  Object.entries(toolbarButtons).forEach(([id, handler]) => {
                      const element = document.getElementById(id);
                      if (element) {
                          element.addEventListener("click", handler);
                      }
                  });

                  document.addEventListener("keydown", (e) => {
                      const isEditing = e.target.isContentEditable ||
                          e.target.tagName === "INPUT" ||
                          e.target.tagName === "TEXTAREA";

                      if (!isEditing) {
                          if (e.key === "ArrowRight") {
                              e.preventDefault();
                              this.nextSlide();
                          } else if (e.key === "ArrowLeft") {
                              e.preventDefault();
                              this.prevSlide();
                          } else if (e.key === "Escape") {
                              e.preventDefault();
                              if (this.isEditMode) {
                                  this.toggleEditMode();
                              }
                          }
                      }

                      if ((e.ctrlKey || e.metaKey) && e.key === "z" && !e.shiftKey) {
                          e.preventDefault();
                          this.undo();
                      }

                      if (((e.ctrlKey || e.metaKey) && e.key === "z" && e.shiftKey) ||
                          ((e.ctrlKey || e.metaKey) && e.key === "y")) {
                          e.preventDefault();
                          this.redo();
                      }

                      if ((e.ctrlKey || e.metaKey) && e.key === "s") {
                          e.preventDefault();
                          this.saveToLocalStorage();

                          const saveIndicator = document.createElement("div");
                          saveIndicator.textContent = "已保存";
                          saveIndicator.style.position = "fixed";
                          saveIndicator.style.bottom = "20px";
                          saveIndicator.style.right = "20px";
                          saveIndicator.style.padding = "10px 20px";
                          saveIndicator.style.backgroundColor = "#2ecc71";
                          saveIndicator.style.color = "white";
                          saveIndicator.style.borderRadius = "5px";
                          saveIndicator.style.zIndex = "9999";
                          document.body.appendChild(saveIndicator);

                          setTimeout(() => {
                              saveIndicator.remove();
                          }, 2000);
                      }
                  });

                  document.addEventListener("fullscreenchange", () => {
                      if (!document.fullscreenElement) {
                          document.body.classList.remove("fullscreen");
                          const navButtons = document.querySelector(".nav-buttons");
                          if (navButtons) navButtons.style.display = "flex";
                      }
                  });

                  const contextMenu = document.getElementById("context-menu");
                  if (contextMenu) {
                      const contextItems = contextMenu.querySelectorAll(".context-item");
                      contextItems.forEach((item) => {
                          item.addEventListener("click", () => {
                              const action = item.getAttribute("data-action");
                              const elementId = contextMenu.getAttribute("data-element-id");
                              const element = this.editManager.elements.get(elementId);

                              if (element) {
                                  switch (action) {
                                      case "duplicate":
                                          const duplicated = element.duplicate();
                                          this.slides[this.currentSlideIndex].addElement(duplicated);
                                          this.renderSlides();
                                          break;
                                      case "delete":
                                          if (element.delete()) {
                                              this.slides[this.currentSlideIndex].removeElement(element.id);
                                          }
                                          break;
                                      case "bring-to-front":
                                          element.bringToFront();
                                          break;
                                      case "send-to-back":
                                          element.sendToBack();
                                          break;
                                  }
                              }

                              contextMenu.classList.remove("show");
                          });
                      });
                  }
                   
                  // 添加全屏模式下的窗口大小变化事件
                  window.addEventListener('resize', () => {
                      if (document.fullscreenElement && document.body.classList.contains('fullscreen')) {
                          this.zoomToFitFullscreen();
                      }
                  });
              }

              // 全屏切换方法
              toggleFullscreen() {
                  const presentationArea = document.getElementById("presentation-area");
                  if (!presentationArea) return;

                  if (!document.fullscreenElement) {
                      if (presentationArea.requestFullscreen) {
                          presentationArea.requestFullscreen();
                      } else if (presentationArea.webkitRequestFullscreen) {
                          presentationArea.webkitRequestFullscreen();
                      } else if (presentationArea.msRequestFullscreen) {
                          presentationArea.msRequestFullscreen();
                      }

                      document.body.classList.add("fullscreen");
                      const navButtons = document.querySelector(".nav-buttons");
                      if (navButtons) navButtons.style.display = "none";

                      // 添加全屏模式下的点击事件监听器
                      this.addFullscreenClickHandler();

                      setTimeout(() => {
                          this.renderSlides();
                          this.zoomToFitFullscreen();
                      }, 100);
                  } else {
                      if (document.exitFullscreen) {
                          document.exitFullscreen();
                      } else if (document.webkitExitFullscreen) {
                          document.webkitExitFullscreen();
                      } else if (document.msExitFullscreen) {
                          document.msExitFullscreen();
                      }

                      document.body.classList.remove("fullscreen");
                      const navButtons = document.querySelector(".nav-buttons");
                      if (navButtons) navButtons.style.display = "flex";

                      // 移除全屏模式下的点击事件监听器
                      this.removeFullscreenClickHandler();

                      setTimeout(() => {
                          this.resetSlideStyles();
                          this.renderSlides();
                      }, 100);
                  }
              }

              // 添加全屏模式下的点击翻页功能
              addFullscreenClickHandler() {
                  const presentationArea = document.getElementById("presentation-area");
                  if (!presentationArea) return;

                  this.fullscreenClickHandler = (e) => {
                      // 确保只有直接点击presentation-area才触发翻页
                      if (e.target === presentationArea || e.target === presentationArea.firstElementChild) {
                          // 计算屏幕宽度的中点
                          const midpoint = window.innerWidth / 2;
                           
                          // 根据点击位置决定翻页方向
                          if (e.clientX < midpoint && this.currentSlideIndex > 0) {
                              // 点击屏幕左侧，显示上一页
                              this.prevSlide();
                              this.showClickFeedback(e.clientX, e.clientY, 'left');
                          } else if (e.clientX >= midpoint && this.currentSlideIndex < this.slides.length - 1) {
                              // 点击屏幕右侧，显示下一页
                              this.nextSlide();
                              this.showClickFeedback(e.clientX, e.clientY, 'right');
                          }
                      }
                  };

                  presentationArea.addEventListener('click', this.fullscreenClickHandler);
              }

              // 移除全屏模式下的点击事件监听器
              removeFullscreenClickHandler() {
                  const presentationArea = document.getElementById("presentation-area");
                  if (!presentationArea || !this.fullscreenClickHandler) return;

                  presentationArea.removeEventListener('click', this.fullscreenClickHandler);
                  this.fullscreenClickHandler = null;
              }

              // 显示点击反馈效果
              showClickFeedback(x, y, direction) {
                  // 创建反馈元素
                  const feedback = document.createElement('div');
                  feedback.className = 'click-feedback';
                  feedback.style.position = 'fixed';
                  feedback.style.left = `${x}px`;
                  feedback.style.top = `${y}px`;
                  feedback.style.width = '60px';
                  feedback.style.height = '60px';
                  feedback.style.borderRadius = '50%';
                  feedback.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
                  feedback.style.transform = 'translate(-50%, -50%) scale(0)';
                  feedback.style.opacity = '0';
                  feedback.style.pointerEvents = 'none';
                  feedback.style.zIndex = '9999';
                  feedback.style.transition = 'all 0.4s ease-out';

                  // 添加图标指示方向
                  if (direction === 'left') {
                      feedback.innerHTML = '<span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 20px;">←</span>';
                  } else {
                      feedback.innerHTML = '<span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 20px;">→</span>';
                  }

                  document.body.appendChild(feedback);

                  // 触发动画
                  setTimeout(() => {
                      feedback.style.transform = 'translate(-50%, -50%) scale(1)';
                      feedback.style.opacity = '1';
                  }, 10);

                  // 移除反馈元素
                  setTimeout(() => {
                      feedback.style.transform = 'translate(-50%, -50%) scale(1.5)';
                      feedback.style.opacity = '0';
                      setTimeout(() => {
                          document.body.removeChild(feedback);
                      }, 400);
                  }, 600);
              }

              // 缩放适配全屏的方法
              zoomToFitFullscreen() {
                  const activeSlide = document.querySelector('.slide.active');
                  if (!activeSlide) return;
                  
                  // 计算屏幕与幻灯片的宽高比
                  const screenRatio = window.innerWidth / window.innerHeight;
                  const slideRatio = 16 / 9; // 标准PPT比例
                  
                  // 计算缩放比例
                  let scale = 1;
                  if (screenRatio > slideRatio) {
                      // 屏幕更宽，按高度缩放
                      scale = window.innerHeight / 576; // 576是原始高度
                  } else {
                      // 屏幕更高，按宽度缩放
                      scale = window.innerWidth / 1024; // 1024是原始宽度
                  }
                  
                  // 应用缩放和居中
                  activeSlide.style.transform = `scale(${scale})`;
                  activeSlide.style.transformOrigin = 'center center';
                  activeSlide.style.width = '1024px';
                  activeSlide.style.height = '576px';
                  activeSlide.style.left = '50%';
                  activeSlide.style.top = '50%';
                  activeSlide.style.marginLeft = '-512px';
                  activeSlide.style.marginTop = '-288px';
              }
               
              // 重置幻灯片样式（退出全屏时使用）
              resetSlideStyles() {
                  const activeSlide = document.querySelector('.slide.active');
                  if (!activeSlide) return;
                  
                  // 移除通过JavaScript设置的内联样式
                  activeSlide.style.transform = '';
                  activeSlide.style.transformOrigin = '';
                  activeSlide.style.width = '';
                  activeSlide.style.height = '';
                  activeSlide.style.left = '';
                  activeSlide.style.top = '';
                  activeSlide.style.marginLeft = '';
                  activeSlide.style.marginTop = '';
              }

              // 导出JSON功能
              exportToJSON() {
                  try {
                      // 收集演示文稿数据
                      const presentationData = {
                          slides: this.slides.map((slide) => {
                              return {
                                  title: slide.title,
                                  backgroundColor: slide.backgroundColor,
                                  backgroundImage: slide.backgroundImage,
                                  elements: slide.elements.map((element) => element.getState()),
                              };
                          }),
                          currentSlideIndex: this.currentSlideIndex,
                          version: '1.0',
                          exportDate: new Date().toISOString(),
                          // 包含注册的自定义元素
                          customElements: this.importedCustomElements && this.importedCustomElements.length > 0 ? this.importedCustomElements : Array.from(ElementRegistry.customElements.entries()).map(([typeName, elementClass]) => {
                              // 获取元素原型
                              const prototype = elementClass.prototype;
                              
                              // 为不同类型的自定义元素提供更合适的模板
                              let template = undefined;
                              
                              // 判断元素类型并提供相应的模板
                              if (typeName === 'gradient-panel') {
                                  template = `<div style="background: linear-gradient(145deg, {{color1}}, {{color2}}); border-radius: 12px; padding: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);">
                                      <div class="gradient-title" style="color: {{textColor}}; font-size: 20px; font-weight: bold; margin-bottom: 15px;">{{title}}</div>
                                      <div class="gradient-content" style="color: {{textColor}};">{{content}}</div>
                                  </div>`;
                              } else if (typeName === 'progress-ring') {
                                  template = `<div style="display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 100%;">
                                      <svg width="{{size}}" height="{{size}}" viewBox="0 0 100 100">
                                          <circle cx="50" cy="50" r="45" stroke="{{trackColor}}" stroke-width="8" fill="none" stroke-linecap="round"/>
                                          <circle cx="50" cy="50" r="45" stroke="{{color}}" stroke-width="8" fill="none" stroke-linecap="round" stroke-dasharray="283" stroke-dashoffset="{{dashOffset}}" transform="rotate(-90 50 50)"/>
                                      </svg>
                                      <div style="margin-top: 10px; font-size: {{textSize}}px; font-weight: bold;">{{value}}%</div>
                                      <div style="font-size: 14px; color: #666;">{{label}}</div>
                                  </div>`;
                              } else if (typeName === 'tech-stack') {
                                  template = `<div style="padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #007bff;">
                                      <h3 style="margin-top: 0; color: #333;">{{title}}</h3>
                                      <div class="tech-items" style="display: flex; flex-wrap: wrap; gap: 10px; margin-top: 15px;">{{items}}</div>
                                  </div>`;
                              } else {
                                  // 对于其他类型的元素，尝试提取模板或提供通用模板
                                  template = prototype.renderContent ? this.extractTemplateFromRender(prototype.renderContent.toString()) : 
                                      `<div style="padding: 20px; border: 2px dashed #ccc; border-radius: 8px;">
                                          <h3>自定义元素: ${typeName}</h3>
                                          <p>这是一个自定义元素，请确保导入后有相应的渲染逻辑。</p>
                                      </div>`;
                              }
                              
                                  // 提取变量信息
                                  const variables = [];
                                  if (template) {
                                      // 查找所有的 {{variable}} 格式的变量
                                      const variableRegex = /{{\s*(\w+)\s*}}/g;
                                      let match;
                                      while ((match = variableRegex.exec(template)) !== null) {
                                          if (!variables.includes(match[1])) {
                                              variables.push(match[1]);
                                          }
                                      }
                                  }
                                  
                                  return {
                                      type: typeName,
                                      template: template,
                                      version: '1.0',
                                      description: `自定义元素: ${typeName}`,
                                      variables: variables,
                                      // 添加渲染类型标识
                                      renderType: 'template'
                                  };
                              })
                      };

                      // 转换为格式化的JSON字符串
                      const jsonString = JSON.stringify(presentationData, null, 2);

                      // 创建Blob对象
                      const blob = new Blob([jsonString], { type: 'application/json' });

                      // 创建下载链接
                      const url = URL.createObjectURL(blob);
                      const a = document.createElement('a');
                      a.href = url;
                      a.download = `AI_PPT_设计_${new Date().toLocaleDateString().replace(/\//g, '-')}.json`;
                      document.body.appendChild(a);

                      // 触发下载
                      a.click();

                      // 清理
                      setTimeout(() => {
                          document.body.removeChild(a);
                          URL.revokeObjectURL(url);
                      }, 100);

                      showNotification('JSON设计导出成功！', 'success');
                  } catch (error) {
                      console.error('JSON导出失败:', error);
                      showNotification('JSON导出失败，请重试。', 'error');
                  }
              }

              addJSONImportFeature() {
                // 创建隐藏的文件输入
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.json';
                fileInput.style.display = 'none';
                fileInput.id = 'json-file-input';
                document.body.appendChild(fileInput);

                // 绑定导入按钮事件
                const importButton = document.getElementById('import-json');
                if (importButton) {
                  importButton.addEventListener('click', () => {
                    fileInput.click();
                  });
                }

                // 处理文件选择
                fileInput.addEventListener('change', (e) => {
                  const file = e.target.files[0];
                  if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                      try {
                        const jsonData = JSON.parse(event.target.result);
                        this.importFromJSON(jsonData);
                        showNotification('JSON设计导入成功！', 'success');
                      } catch (error) {
                        console.error('JSON解析错误:', error);
                        showNotification('JSON文件格式错误，请检查文件内容', 'error');
                      }
                    };
                    reader.onerror = () => {
                      showNotification('文件读取失败', 'error');
                    };
                    reader.readAsText(file);
                  }

                  // 重置文件输入，允许选择同一个文件再次导入
                  fileInput.value = '';
                });
              }

              importFromJSON(jsonData) {
                  try {
                      // 创建历史快照
                      this.createSnapshot();

                      // 清空当前内容
                      this.slides = [];
                      this.editManager.cleanup();

                      // 1. 注册自定义元素
                      if (jsonData.customElements && Array.isArray(jsonData.customElements)) {
                          // 存储导入的自定义元素信息，以便导出时使用
                          this.importedCustomElements = jsonData.customElements;
                          this.registerCustomElements(jsonData.customElements);
                      } else {
                          // 如果没有自定义元素，清空存储
                          this.importedCustomElements = [];
                      }

                      // 2. 注入自定义样式
                      if (jsonData.styles) {
                          this.injectCustomStyles(jsonData.styles);
                      }

                      // 3. 创建幻灯片
                      if (jsonData.slides && Array.isArray(jsonData.slides)) {
                          this.createSlidesFromJSON(jsonData.slides);
                      }

                      // 4. 设置标题
                      if (jsonData.title) {
                          document.title = jsonData.title + ' - AI PPT生成系统';
                      }

                      // 5. 切换到第一张幻灯片
                      this.currentSlideIndex = 0;

                      // 6. 先渲染幻灯片，确保DOM已创建
                      this.renderSlides();
                      this.renderSlideList();

                      // 7. 特别处理图表元素，确保它们在DOM渲染完成后再渲染
                      setTimeout(() => {
                          if (this.slides[this.currentSlideIndex]) {
                              this.slides[this.currentSlideIndex].renderElements();
                          }
                      }, 200);

                      // 8. 保存到本地存储
                      this.saveToLocalStorage();

                      console.log('JSON导入成功:', jsonData);
                      showNotification('JSON设计导入成功！', 'success');
                      return true;
                  } catch (error) {
                      console.error('JSON导入失败:', error);
                      showNotification('导入失败: ' + error.message, 'error');
                      return false;
                  }
              }

              // 从renderContent函数中提取模板字符串
              extractTemplateFromRender(renderFunctionStr) {
                  try {
                      console.log('正在提取模板:', renderFunctionStr);
                       
                      // 尝试提取完整的模板定义块
                      // 匹配任何以template = 开头，以分号结尾的语句
                      const fullTemplateMatch = renderFunctionStr.match(/let\s+template\s*=\s*([\s\S]*?);/);
                      if (fullTemplateMatch && fullTemplateMatch[1]) {
                          // 处理可能包含 || 操作符的模板定义
                          const templateValue = fullTemplateMatch[1].trim();
                          console.log('找到完整模板定义:', templateValue);
                           
                          // 检查是否包含 || 操作符（如 elementDef.template || `...`）
                          const fallbackMatch = templateValue.match(/\|\|\s*(`[^`]*`|'[^']*'|"[^"]*")/);
                          if (fallbackMatch && fallbackMatch[1]) {
                              // 提取回退模板
                              const fallbackTemplate = fallbackMatch[1].slice(1, -1); // 移除引号
                              console.log('提取到回退模板:', fallbackTemplate);
                              return fallbackTemplate;
                          }
                          
                          // 提取直接赋值的模板字符串
                          const templateStrMatch = templateValue.match(/^(`[^`]*`|'[^']*'|"[^"]*")$/);
                          if (templateStrMatch && templateStrMatch[1]) {
                              const templateStr = templateStrMatch[1].slice(1, -1); // 移除引号
                              console.log('提取到直接模板字符串:', templateStr);
                              return templateStr;
                          }
                      }
                       
                      // 尝试提取innerHTML设置
                      const innerHTMLMatch = renderFunctionStr.match(/this\.element\.innerHTML\s*=\s*(template|(`[^`]*`|'[^']*'|"[^"]*"));/);
                      if (innerHTMLMatch && innerHTMLMatch[1]) {
                          console.log('找到innerHTML设置:', innerHTMLMatch[1]);
                          if (innerHTMLMatch[1] === 'template') {
                              // 如果是使用模板变量，不再递归调用，而是返回空字符串或占位符
                              return '<!-- 模板使用了变量引用，无法直接提取 -->';
                          } else {
                              // 如果是直接设置的字符串，则提取它
                              return innerHTMLMatch[1].slice(1, -1); // 移除引号
                          }
                      }
                       
                      // 尝试直接提取HTML字符串片段
                      const htmlContentMatch = renderFunctionStr.match(/`<div[^`]*>`/);
                      if (htmlContentMatch && htmlContentMatch[0]) {
                          console.log('提取到HTML内容:', htmlContentMatch[0]);
                          return htmlContentMatch[0].slice(1, -1); // 移除反引号
                      }
                       
                      console.log('未能提取模板');
                      return undefined;
                  } catch (error) {
                      console.warn('提取模板失败:', error);
                      return undefined;
                  }
              }

              registerCustomElements(customElements) {
                  customElements.forEach((elementDef) => {
                      try {
                          // 动态创建继承自BaseElement的自定义元素类
                          const CustomElementClass = class extends BaseElement {
                              constructor(content, style = {}) {
                                  super(elementDef.type, content, style);
                              }

                              renderContent() {
                                  let template = elementDef.template || `<div style="padding: 20px; border: 2px dashed #ccc; border-radius: 8px;">
                                      <h3>自定义元素: ${elementDef.type}</h3>
                                      <p>请定义模板</p>
                                  </div>`;

                                  // 替换模板变量
                                  template = this.replaceTemplateVariables(template, this.content);

                                  // 将模板内容设置到元素中
                                  this.element.innerHTML = template;
                              }

                              // 替换模板中的变量
                              replaceTemplateVariables(template, variables) {
                                  if (!variables || typeof variables !== 'object') {
                                      return template;
                                  }

                                  let result = template;

                                  // 替换简单变量 {{variable}}
                                  Object.keys(variables).forEach(key => {
                                      const value = this.extractDisplayValue(variables[key]);
                                      const regex = new RegExp(`{{\s*${key}\s*}}`, 'g');
                                      result = result.replace(regex, value);
                                  });

                                  // 替换数组循环 {{each array}}...{{/each}}
                                  const eachRegex = /{{\s*each\s+([\w]+)\s*}}([\s\S]*?){{\s*\/each\s*}}/g;
                                  let match;
                                  while ((match = eachRegex.exec(result)) !== null) {
                                      const arrayName = match[1];
                                      const itemTemplate = match[2];
                                      const array = variables[arrayName];

                                      if (Array.isArray(array)) {
                                          let arrayHtml = '';
                                          array.forEach((item, index) => {
                                              let itemHtml = itemTemplate;

                                              // 替换数组项中的变量
                                              if (typeof item === 'object') {
                                                  Object.keys(item).forEach(itemKey => {
                                                      const value = this.extractDisplayValue(item[itemKey]);
                                                      const itemRegex = new RegExp(`{{\s*${itemKey}\s*}}`, 'g');
                                                      itemHtml = itemHtml.replace(itemRegex, value);
                                                  });
                                              } else {
                                                  // 简单数组项，使用{{this}}引用当前项
                                                  const value = this.extractDisplayValue(item);
                                                  itemHtml = itemHtml.replace(/{{\s*this\s*}}/g, value);
                                              }

                                              // 替换索引变量，同时支持{{index}}和{{@index}}两种格式
                                              itemHtml = itemHtml.replace(/{{\s*@?index\s*}}/g, index);
                                              arrayHtml += itemHtml;
                                          });
                                          result = result.replace(match[0], arrayHtml);
                                      } else {
                                          // 如果不是数组，移除这个each块
                                          result = result.replace(match[0], '');
                                      }
                                  }

                                  return result;
                              }

                              // 提取变量的显示值
                              extractDisplayValue(value) {
                                  if (value === null || value === undefined) {
                                      return '';
                                  }
                                  if (typeof value === 'object') {
                                      return JSON.stringify(value);
                                  }
                                  return String(value);
                              }

                              // 让元素内容可编辑
                              makeContentEditable() {
                                  const element = $(`#${this.id}`);
                                  if (!element) return;

                                  // 为所有文本节点添加contenteditable属性
                                  const addEditableToTextNodes = (parent) => {
                                      Array.from(parent.childNodes).forEach(node => {
                                          if (node.nodeType === 3 && node.textContent.trim()) {
                                              // 文本节点
                                              const wrapper = document.createElement('span');
                                              wrapper.setAttribute('contenteditable', 'true');
                                              wrapper.textContent = node.textContent;
                                              node.parentNode.insertBefore(wrapper, node);
                                              node.parentNode.removeChild(node);

                                              // 添加事件监听
                                              const blurHandler = () => {
                                                  // 当内容变化时，尝试更新对应的变量
                                                  this.handleContentUpdate(wrapper, node);
                                              };
                                              wrapper.addEventListener('blur', blurHandler);
                                              this.contentEditableHandlers.push(() => {
                                                  wrapper.removeEventListener('blur', blurHandler);
                                              });
                                          } else if (node.nodeType === 1) {
                                              // 元素节点
                                              addEditableToTextNodes(node);
                                          }
                                      });
                                  };

                                  addEditableToTextNodes(element);
                              }

                              // 处理内容更新
                              handleContentUpdate(element, originalNode) {
                                  // 这个方法可以根据实际需求进行扩展
                                  // 目前简单实现，实际项目中可能需要更复杂的变量映射逻辑
                                  this.updateElement();
                                  if (window.pptManager) {
                                      window.pptManager.saveToLocalStorage();
                                  }
                              }
                          };

                          // 注册自定义元素类型
                          ElementRegistry.registerElementType(elementDef.type, CustomElementClass);
                          console.log(`成功注册自定义元素: ${elementDef.type}`);
                      } catch (error) {
                          console.error(`注册自定义元素${elementDef.type}失败:`, error);
                          showNotification(`注册元素${elementDef.type}失败: ${error.message}`, "error");
                      }
                  });
              }

              injectCustomStyles(css) {
                  const existingStyle = document.getElementById("custom-styles");
                  if (existingStyle) {
                      existingStyle.remove();
                  }

                  const styleElement = document.createElement("style");
                  styleElement.id = "custom-styles";
                  styleElement.textContent = css;
                  document.head.appendChild(styleElement);
              }

              createSlidesFromJSON(slidesData) {
                  slidesData.forEach((slideConfig) => {
                      const slide = new Slide(slideConfig.title || "未命名幻灯片");

                      if (slideConfig.backgroundColor) {
                          slide.backgroundColor = slideConfig.backgroundColor;
                      }

                      if (slideConfig.elements && Array.isArray(slideConfig.elements)) {
                          slideConfig.elements.forEach((elementConfig) => {
                              try {
                                  const element = ElementRegistry.createElement(
                                      elementConfig.type,
                                      elementConfig.content || {},
                                      elementConfig.style || {}
                                  );

                                  if (elementConfig.position) {
                                      element.position = elementConfig.position;
                                  }
                                  if (elementConfig.size) {
                                      element.size = elementConfig.size;
                                  }
                                  if (elementConfig.rotation) {
                                      element.rotation = elementConfig.rotation;
                                  }
                                  if (elementConfig.zIndex) {
                                      element.zIndex = elementConfig.zIndex;
                                  }

                                  slide.addElement(element);
                              } catch (error) {
                                  console.error("创建元素失败:", elementConfig, error);
                              }
                          });
                      }

                      this.slides.push(slide);
                  });
              }
          }

          // ==================== 初始化应用 ====================
          document.addEventListener("DOMContentLoaded", function() {
              window.pptManager = new PPTManager();

              // 添加示例幻灯片
              const secondSlide = window.pptManager.addSlide("数据可视化");
              secondSlide.addElement(
                  new ChartElement({
                      chartOption: {
                          title: { text: "销售数据统计" },
                          tooltip: {},
                          legend: { data: ["销量"] },
                          xAxis: { data: ["1月", "2月", "3月", "4月", "5月", "6月"] },
                          yAxis: {},
                          series: [
                              {
                                  name: "销量",
                                  type: "line",
                                  data: [120, 200, 150, 80, 70, 110],
                              },
                          ],
                      },
                  })
              );

              const thirdSlide = window.pptManager.addSlide("自定义元素展示");
              thirdSlide.addElement(
                  new GradientPanelElement({
                      color1: "#2A5CFF",
                      color2: "#638DFF",
                      title: "渐变面板示例",
                      content: "这是一个渐变面板自定义元素",
                      textColor: "#FFFFFF"
                  })
              );

              thirdSlide.addElement(
                  new ProgressRingElement({
                      value: 65,
                      size: 80,
                      progressColor: "#10B981",
                      trackColor: "#E5E7EB",
                      textColor: "#1F2937"
                  })
              );

              // 重新渲染幻灯片
              window.pptManager.renderSlides();

              // 暴露必要的API到全局
              window.pptApp = {
                  addSlide: window.pptManager.addSlide.bind(window.pptManager),
                  savePresentation: window.pptManager.saveAsPPT.bind(window.pptManager),
                  addElement: window.pptManager.addElement.bind(window.pptManager),
              };
          });

      })();
    </script>
  </body>
</html>
